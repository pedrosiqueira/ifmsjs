<!DOCTYPE html>

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <!-- <script src="https://unpkg.com/highlightjs-svelte/dist/svelte.min.js"></script> -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlightjs-line-numbers.js/2.9.0/highlightjs-line-numbers.min.js"></script>
    <script defer>hljs.configure({ languages: ["javascript"] }); hljs.highlightAll(); hljs.initLineNumbersOnLoad();</script>

    <!-- https://github.com/arronhunt/highlightjs-copy -->
    <link rel="stylesheet" href="https://unpkg.com/highlightjs-copy/dist/highlightjs-copy.min.css" />
    <script src="https://unpkg.com/highlightjs-copy/dist/highlightjs-copy.min.js"></script>
    <script defer>hljs.addPlugin(new CopyButtonPlugin());</script>

    <!-- https://github.com/TRSasasusu/highlightjs-highlight-lines.js -->
    <!-- <script src="https://cdn.jsdelivr.net/gh/TRSasasusu/highlightjs-highlight-lines.js@1.2.0/highlightjs-highlight-lines.min.js"></script>
  <script defer>hljs.highlightLinesAll([
      // [{ start: 2, end: 2, color: 'lightgreen' }, { start: 9, end: 9, color: 'lightblue' }, { start: 14, end: 14, color: 'lightblue' }]
    ]);
  </script> -->

    <!-- <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css" integrity="sha384-n8MVd4RsNIU0tAv4ct0nTaAbDJwPJzDEaqSD1odI+WdtXRGWt2kTvGFasHpSy3SV" crossorigin="anonymous">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js" integrity="sha384-XjKyOOlGwcjNTAIQHIpgOno0Hl1YQqzUOEleOLALmuqehneUG+vnGctmUb0ZY0l8" crossorigin="anonymous"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js" integrity="sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05" crossorigin="anonymous" onload="renderMathInElement(document.body,{delimiters:[{left: '$$', right: '$$', display: true},{left: '$', right: '$', display: false}]});"></script> -->

    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/pedrosiqueira/custom-style/custom.min.css">
    <script src="https://cdn.jsdelivr.net/gh/pedrosiqueira/custom-style/custom.min.js"></script>
</head>

<h1>Dicas para trabalhar com DrizzleORM</h1>

<h2>Importa√ß√µes</h2>
<p>Em arquivos <code>schema.js</code>, fazemos importa√ß√µes do tipo:</p>
<pre><code>import { sql } from 'drizzle-orm';
import { blob, check, index, integer, real, sqliteTable, text, uniqueIndex } from "drizzle-orm/sqlite-core";</code></pre>

<p>Em arquivos que realizam opera√ß√µes no banco, fazemos importa√ß√µes do tipo:</p>
<pre><code>import { db } from '$lib/server/db';
import * as tabela from '$lib/server/db/schema';
import { and, asc, count, desc, eq, gt, like, lt, max, min, sql, sum } from 'drizzle-orm';
</code></pre>

<p>Adapte as importa√ß√µes conforme a necessidade.</p>

<h2>Consultas</h2>

<h3>Express√µes v√°lidas</h3>
<p>Para realizar uma consulta, podemos combinar qualquer fun√ß√£o dispon√≠vel, desde que seja uma express√£o v√°lida.</p>
<p><strong>Pergunta:</strong> O que essa consulta faz?</p>
<table class="custom">
    <thead>
        <tr>
            <th>C√≥digo</th>
            <th>Sa√≠da</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>
                <pre><code>const consulta = await db
    .select({ titulo: tabela.posts.titulo, nome: tabela.usuarios.nome })
    .from(tabela.posts)
    .where(
        and(
            gt(tabela.posts.criado_em, '2020-01-01 00:00:00'),
            lt(tabela.posts.criado_em, '2030-12-31 23:59:59')
        ))
    .innerJoin(tabela.usuarios, eq(tabela.usuarios.id, tabela.posts.usuario_id))
    .orderBy(desc(tabela.posts.criado_em));

console.log(consulta);</code></pre>
            </td>
            <td>
                <pre><code>[
  { titulo: 'primeiro artigo', nome: 'maria_silva' },
  { titulo: 'segundo artigo', nome: 'francisca_pereira' },
  { titulo: 'terceiro artigo', nome: 'francisca_pereira' },
  { titulo: 'quarto artigo', nome: 'maria_silva' },
  { titulo: 'quinto artigo', nome: 'francisca_pereira' }
]</code></pre>
            </td>
        </tr>
    </tbody>
</table>

<h3>Obtendo um √∫nico item</h3>
<p>Especialmente quando buscamos um objeto pela chave prim√°ria, sabemos que o resultado sempre ser√° um √∫nico objeto. Por√©m o <code>select</code> sempre retorna uma lista, mesmo que seja uma lista de um √∫nico item.</p>
<table class="custom">
    <thead>
        <tr>
            <th>C√≥digo</th>
            <th>Sa√≠da</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>
                <pre><code>const lista = await db.select().from(tabela.usuarios)
.where(eq(tabela.usuarios.id, 2)).limit(1);

console.log(lista);
console.log(lista[0].nome);</code></pre>
            </td>
            <td>
                <pre><code>[
  {
    id: 2,
    nome: 'francisca_pereira',
    email: 'francisca@pereira.com',
    nascimento: '2002-11-05',
    pontos: 0,
    criado_em: '2025-03-31 16:45:03'
  }
]
francisca_pereira</code></pre>
            </td>
        </tr>
    </tbody>
</table>

<p>Em casos que voc√™ precisa apenas de um √∫nico item, ou do primeiro item da lista, voc√™ pode usar a <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring">sintaxe de desestrutura√ß√£o</a> do JavaScript:</p>
<table class="custom">
    <thead>
        <tr>
            <th>C√≥digo</th>
            <th>Sa√≠da</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>
                <pre><code>const [usuario] = await db.select().from(tabela.usuarios)
.where(eq(tabela.usuarios.id, 2)).limit(1);

console.log(usuario);
console.log(usuario.nome);</code></pre>
            </td>
            <td>
                <pre><code>{
  id: 2,
  nome: 'francisca_pereira',
  email: 'francisca@pereira.com',
  nascimento: '2002-11-05',
  pontos: 0,
  criado_em: '2025-03-31 16:45:03'
}
francisca_pereira</code></pre>
            </td>
        </tr>
    </tbody>
</table>

<h2>Inser√ß√µes</h2>

<h3>Inserindo objetos ou listas de objetos</h3>
<p>Podemos inserir um objeto apenas...</p>
<pre><code>const pessoa = { nome: 'antonia_rodrigues', email: 'antonia@rodrigues.com' }
await db.insert(tabela.usuarios).values(pessoa);</code></pre>

<p>... Ou uma lista de objetos:</p>
<pre><code>const pessoas = [
    { nome: 'adriana_lima', email: 'adriana@lima.com' },
    { nome: 'luiz_alves', email: 'luiz@alves.com' }
]
await db.insert(tabela.usuarios).values(pessoas);</code></pre>

<h3>Nomes de propriedades abreviados</h3>
<p>Podemos inserir dados na tabela vindos de vari√°veis:</p>
<pre><code>const nome_usuario = 'francisco_ferreira'
const email_usuario = 'francisco@ferreira.com'
await db.insert(tabela.usuarios).values({ nome: nome_usuario, email: email_usuario, });</code></pre>

<p>Em muitos casos, o atributo do objeto e a vari√°vel t√™m o mesmo nome:</p>
<pre><code>const nome = 'francisco_ferreira'
const email = 'francisco@ferreira.com'
await db.insert(tabela.usuarios).values({ nome: nome, email: email, });</code></pre>

<p>Nesses casos, podemos usar a sintaxe de <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Object_initializer#property_definitions">nomes de propriedades abreviados</a>:</p>
<pre><code>const nome = 'francisco_ferreira'
const email = 'francisco@ferreira.com'
await db.insert(tabela.usuarios).values({ nome, email, });</code></pre>

<h3>Retornando o resultado</h3>
<p>Normalmente quando inserimos um objeto no banco, mas n√£o informamos o ID, que √© gerado automaticamente pelo banco. Em muitas situa√ß√µes, precisamos do ID gerado pelo banco. Para essas situa√ß√µes, podemos usar o m√©todo <code>returning</code>, que retorna o objeto rec√©m inserido, j√° com o id gerado:</p>

<table class="custom">
    <thead>
        <tr>
            <th>C√≥digo</th>
            <th>Sa√≠da</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>
                <pre><code>const usuario = {
    nome: 'marcia_nascimento',
    email: 'marcia@nascimento.com'
}

const [novoUsuario] = await db
.insert(tabela.usuarios).values(usuario).returning();

console.log("Antes:", usuario);
console.log("Depois:", novoUsuario);</code></pre>
            </td>
            <td>
                <pre><code>Antes: {
    nome: 'marcia_nascimento',
    email: 'marcia@nascimento.com'
}

Depois: {
  id: 6,
  nome: 'marcia_nascimento',
  email: 'marcia@nascimento.com',
  nascimento: null,
  pontos: 0,
  criado_em: '2025-04-04 13:28:47'
}</code></pre>
            </td>
        </tr>
    </tbody>
</table>

<p>Geralmente, quando inserimos um objeto, como os outros atributos j√° temos, podemos querer apenas os atributos que s√£o gerados pelo banco. Podemos filtrar quais atributos queremos retornar ao inserir:</p>

<table class="custom">
    <thead>
        <tr>
            <th>C√≥digo</th>
            <th>Sa√≠da</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>
                <pre><code>const usuario = { nome: 'carlos_gomes', email: 'carlos@gomes.com' }

const [criado] = await db.insert(tabela.usuarios)
    .values(usuario).returning({
        id: tabela.usuarios.id,
        criacao: tabela.usuarios.criado_em
    });

console.log("Usu√°rio criado:", criado);</code></pre>
            </td>
            <td>
                <pre><code>Usu√°rio criado: { id: 7, criacao: '2025-04-04 15:10:06' }</code></pre>
            </td>
        </tr>
    </tbody>
</table>

<p>Quando precisamso apenas do ID, este ainda seria retornado dentro de um objeto. Podemos usar a <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring">sintaxe de desestrutura√ß√£o</a> para obter apenas o ID do objeto retornado:</p>
<table class="custom">
    <thead>
        <tr>
            <th>C√≥digo</th>
            <th>Sa√≠da</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>
                <pre><code>const usuario = { nome: 'juliany_jesus', email: 'juliana@jesus.com' }

const [{ id }] = await db.insert(tabela.usuarios)
.values(usuario).returning({ id: tabela.usuarios.id });

console.log("ID:", id);</code></pre>
            </td>
            <td>
                <pre><code>ID: 8</code></pre>
            </td>
        </tr>
    </tbody>
</table>

<h2>Atualiza√ß√µes</h2>
<p>Atualiza√ß√µes s√£o muito parecidas com consultas. Os seguintes trechos fazem a mesma coisa:</p>
<table class="custom align-left">
    <thead>
        <tr>
            <th>C√≥digo</th>
            <th>Situa√ß√£o</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>
                <pre><code>const nome = 'marcia_nascimento';
const pontuacao = 50;
const data_nascimento = '2003-04-05';

await db.update(tabela.usuarios)
    .set({ pontos: pontuacao, nascimento: data_nascimento })
    .where(eq(tabela.usuarios.nome, nome));</code></pre>
            </td>
            <td>Dados vindos de um formul√°rio ou fun√ß√£o.</td>
        </tr>
        <tr>
            <td>
                <pre><code>const nome: 'marcia_nascimento';
const pontos = 50;
const nascimento = '2003-04-05';

await db.update(tabela.usuarios)
    .set({ pontos, nascimento })
    .where(eq(tabela.usuarios.nome, nome));</code></pre>
            </td>
            <td>Dados vindos de um formul√°rio ou fun√ß√£o, e coincidem com os atributos do objeto.</td>
        </tr>
        <tr>
            <td>
                <pre><code>const usuario = {
    nome: 'marcia_nascimento',
    email: 'marcia@nascimento.com',
    pontos: 50, nascimento: '2003-04-05'
};

await db.update(tabela.usuarios).set(usuario)
    .where(eq(tabela.usuarios.nome, usuario.nome));</code></pre>
            </td>
            <td>Voc√™ tem os campos de atualiza√ß√£o agrupados, ou j√° tinha o objeto e modificou alguns atributos.</td>
        </tr>
        <tr>
            <td>
                <pre><code>await db.update(tabela.usuarios).set({
    pontos: 50,
    nascimento: '2003-04-05'
}).where(eq(tabela.usuarios.nome, 'marcia_nascimento'));</code></pre>
            </td>
            <td>R√°pido e direto. Usado geralmente em scripts de teste ou em pequenos ajustes no banco durante o in√≠cio do projeto.</td>
        </tr>
    </tbody>
</table>

<h2>Inser√ß√µes ou atualiza√ß√µes</h2>
<p>Se tentarmos inserir um objeto com um valor exclusivo (<em>unique</em>) ou chave prim√°ria j√° existente no banco, ocorrer√° um erro. Por exemplo, Se existir algu√©m com email <code>juliana@jesus.com</code> no banco e tentarmos fazer essa opera√ß√£o:</p>
<pre><code>const pessoa = { nome: 'juliana_jesus', email: 'juliana@jesus.com' }
await db.insert(tabela.usuarios).values(pessoa);</code></pre>
<p>Ocorrer√° o erro <code>SQLITE_CONSTRAINT_UNIQUE: UNIQUE constraint failed: usuarios.email</code>.</p>
<p>O DrizzleORM suporta a opera√ß√£o <code>onConflictDoNothing</code>, que cancela a inser√ß√£o se houver um conflito:</p>
<pre><code>const pessoa = { nome: 'juliana_jesus', email: 'juliana@jesus.com' }
await db.insert(tabela.usuarios).values(pessoa).onConflictDoNothing();

// delimita quais atributos n√£o conflitar√£o
await db.insert(tabela.usuarios).values(pessoa)
.onConflictDoNothing({ target: tabela.usuarios.email });</code></pre>

<p>O DrizzleORM tamb√©m suporta a opera√ß√£o <code>onConflictDoUpdate</code>, que primeiramente tenta inserir um objeto, mas se j√° houver um objeto com algum dos campos, ent√£o atualiza ele:</p>

<table class="custom">
    <thead>
        <tr>
            <th>C√≥digo</th>
            <th>Sa√≠da</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>
                <pre><code>// busca um objeto
const [usuarioExistente] = await db.select().from(tabela.usuarios)
    .where(like(tabela.usuarios.nome, 'julian%'));

console.log('Antes da atualiza√ß√£o:', usuarioExistente);

// atualiza o objeto
usuarioExistente.nome = 'juliana_jesus';
usuarioExistente.pontos = 150;

// salva o objeto
const [usuarioAtualizado] = await db.insert(tabela.usuarios)
    .values(usuarioExistente).onConflictDoUpdate({
        target: tabela.usuarios.email,
        set: usuarioExistente
    }).returning();

console.log('Depois da atualiza√ß√£o:', usuarioAtualizado);</code></pre>
            </td>
            <td>
                <pre><code>Antes da atualiza√ß√£o: {
  id: 7,
  nome: 'juliany_jesus',
  email: 'juliana@jesus.com',
  nascimento: null,
  pontos: 0,
  criado_em: '2025-04-08 11:04:54'
}
Depois da atualiza√ß√£o: {
  id: 7,
  nome: 'juliana_jesus',
  email: 'juliana@jesus.com',
  nascimento: null,
  pontos: 150,
  criado_em: '2025-04-08 11:04:54'
}</code></pre>
            </td>
        </tr>
    </tbody>
</table>
<p>O <code>onConflictDoUpdate</code> exige que voc√™ indique qual coluna ou lista de colunas est√° causando o conflito (atributo <code>target</code>), e o que deve ser atualizado em caso de conflito (atributo <code>set</code>).</p>

<h2>Exclus√µes</h2>
<p>Tome muito cuidado com exclus√µes! Nunca fa√ßa algo do tipo:</p>
<pre><del>await db.delete(users);</del></pre>

<p>Ao excluir, voc√™ deve filtrar o que deve ser exclu√≠do:</p>
<pre><code>const id = 1
await db.delete(tabela.posts).where(eq(tabela.posts.id, id));
</code></pre>

<p>Se precisar, pode retornar o objeto exclu√≠do:</p>
<table class="custom">
    <thead>
        <tr>
            <th>C√≥digo</th>
            <th>Sa√≠da</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>
                <pre><code>const id = 4
const [postagemExcluida] = await db.delete(tabela.posts).where(eq(tabela.posts.id, id)).returning();
console.log(postagemExcluida);</code></pre>
            </td>
            <td>
                <pre><code>{
  id: 2,
  titulo: 'segundo artigo',
  conteudo: 'conte√∫do do segundo artigo',
  usuario_id: 2,
  criado_em: '2025-04-09 21:12:48',
  atualizado_em: '2025-04-09 21:12:48'
}</code></pre>
            </td>
        </tr>
    </tbody>
</table>

<h2 id="operador-magico-de-sql">O operador m√°gico <code>sql</code> ü™Ñ</h2>
<p> Ao utilizar uma biblioteca ORM, pode haver situa√ß√µes em que escrever determinada consulta usando apenas a sintaxe da biblioteca se torna desafiador. Nesses casos, √© comum recorrer √†s <strong>consultas brutas</strong> (<em>raw queries</em>), constru√≠das como strings de SQL puro. No entanto, esse tipo de abordagem geralmente <strong>n√£o oferece os benef√≠cios da seguran√ßa de tipos</strong> nem da <strong>parametriza√ß√£o</strong>.</p>
<p> Para contornar esse problema, muitas bibliotecas introduziram o conceito de <strong>template SQL</strong>. Esse recurso permite escrever consultas de forma mais segura e flex√≠vel, com suporte a <strong>tipagem est√°tica</strong> e <strong>par√¢metros protegidos contra inje√ß√£o de SQL</strong>. O <strong>DrizzleORM</strong>, por sua vez, oferece suporte nativo a esse modelo por meio do <a href="https://orm.drizzle.team/docs/sql">template <code>sql</code></a>.</p>
<p>Voc√™ pode utilizar o template <code>sql</code> do Drizzle de forma seletiva em trechos espec√≠ficos da consulta, caso n√£o seja poss√≠vel escrev√™-la completamente com a API do Drizzle. Isso significa que √© poss√≠vel usar o template <code>sql</code> em cl√°usulas como <code>SELECT</code>, <code>WHERE</code>, <code>ORDER BY</code>, <code>HAVING</code>, <code>GROUP BY</code> e at√© mesmo em consultas relacionais.</p>
<p>Ao adotar o template <code>sql</code>, voc√™ mant√©m as vantagens de seguran√ßa de tipos e de parametriza√ß√£o, sem abrir m√£o da flexibilidade necess√°ria para construir consultas mais complexas. Entretanto, esse recurso s√≥ deve ser utilizado quando n√£o for poss√≠vel realizar uma opera√ß√£o usando a pr√≥pria API do Drizzle, o que seria em casos raros.</p>
<p>Por exemplo, uma consulta bruta por todos os t√≠tulos das postagens de um usu√°rio que come√ßa com determinado nome seria:</p>

<table class="custom">
    <thead>
        <tr>
            <th>C√≥digo</th>
            <th>Sa√≠da</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>
                <pre><code>const nome = 'francisca';
const result = await db.all(
    sql`
    SELECT ${tabela.posts.titulo}
    FROM ${tabela.usuarios}
    INNER JOIN ${tabela.posts}
    ON ${tabela.usuarios.id} = ${tabela.posts.usuario_id}
    WHERE ${tabela.usuarios.nome} LIKE ${nome + '%'}
    `
);
console.log(result);</code></pre>
            </td>
            <td>
                <pre><code>[
  { titulo: 'segundo artigo' }, 
  { titulo: 'terceiro artigo' },
  { titulo: 'quinto artigo' }   
]</code></pre>
            </td>
        </tr>
    </tbody>
</table>

<p>No lugar de <code>db.all</code>, voc√™ pode usar <code>db.get</code> caso queira um resultado com apenas um item, ou <code>db.run</code> que traz informa√ß√µes mais detalhadas da consulta.</p>

<h2>Conclus√£o</h2>
<p>muito mais coisas d√° pra fazer com DrizzleORM, como a api de consultas personalizada <a href='https://orm.drizzle.team/docs/rqb'><code>query</code></a>. se vc precisar fazer algo que n√£o foi dito aqui, pode ser que j√° tenha um comando para o que voc√™ estiver precisando. neste caso, recomendo <a href="https://orm.drizzle.team/docs/overview">consultar a documenta√ß√£o</a> e procurar o que deseja.</p>
