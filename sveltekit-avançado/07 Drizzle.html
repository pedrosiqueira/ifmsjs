<!DOCTYPE html>

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <!-- <script src="https://unpkg.com/highlightjs-svelte/dist/svelte.min.js"></script> -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlightjs-line-numbers.js/2.9.0/highlightjs-line-numbers.min.js"></script>
    <script defer>hljs.configure({ languages: ["javascript"] }); hljs.highlightAll(); hljs.initLineNumbersOnLoad();</script>

    <!-- https://github.com/arronhunt/highlightjs-copy -->
    <link rel="stylesheet" href="https://unpkg.com/highlightjs-copy/dist/highlightjs-copy.min.css" />
    <script src="https://unpkg.com/highlightjs-copy/dist/highlightjs-copy.min.js"></script>
    <script defer>hljs.addPlugin(new CopyButtonPlugin());</script>

    <!-- https://github.com/TRSasasusu/highlightjs-highlight-lines.js -->
    <!-- <script src="https://cdn.jsdelivr.net/gh/TRSasasusu/highlightjs-highlight-lines.js@1.2.0/highlightjs-highlight-lines.min.js"></script>
  <script defer>hljs.highlightLinesAll([
      // [{ start: 2, end: 2, color: 'lightgreen' }, { start: 9, end: 9, color: 'lightblue' }, { start: 14, end: 14, color: 'lightblue' }]
    ]);
  </script> -->

    <!-- <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css" integrity="sha384-n8MVd4RsNIU0tAv4ct0nTaAbDJwPJzDEaqSD1odI+WdtXRGWt2kTvGFasHpSy3SV" crossorigin="anonymous">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js" integrity="sha384-XjKyOOlGwcjNTAIQHIpgOno0Hl1YQqzUOEleOLALmuqehneUG+vnGctmUb0ZY0l8" crossorigin="anonymous"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js" integrity="sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05" crossorigin="anonymous" onload="renderMathInElement(document.body,{delimiters:[{left: '$$', right: '$$', display: true},{left: '$', right: '$', display: false}]});"></script> -->

    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/pedrosiqueira/custom-style/custom.min.css">
    <script src="https://cdn.jsdelivr.net/gh/pedrosiqueira/custom-style/custom.min.js"></script>
</head>

<h1>Dicas para trabalhar com DrizzleORM</h1>

<h2>Importações</h2>
<p>Em arquivos <code>schema.js</code>, fazemos importações do tipo:</p>
<pre><code>import { sql } from 'drizzle-orm';
import { blob, check, index, integer, real, sqliteTable, text, uniqueIndex } from "drizzle-orm/sqlite-core";</code></pre>

<p>Em arquivos que realizam operações no banco, fazemos importações do tipo:</p>
<pre><code>import { db } from '$lib/server/db';
import * as tabela from '$lib/server/db/schema';
import { and, asc, count, desc, eq, gt, like, lt, max, min, sql, sum } from 'drizzle-orm';
</code></pre>

<p>Adapte as importações conforme a necessidade.</p>

<h2>Consultas</h2>

<h3>Expressões válidas</h3>
<p>Para realizar uma consulta, podemos combinar qualquer função disponível, desde que seja uma expressão válida.</p>
<p><strong>Pergunta:</strong> O que essa consulta faz?</p>
<table class="custom">
    <thead>
        <tr>
            <th>Código</th>
            <th>Saída</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>
                <pre><code>const consulta = await db
    .select({ titulo: tabela.posts.titulo, nome: tabela.usuarios.nome })
    .from(tabela.posts)
    .where(
        and(
            gt(tabela.posts.criado_em, '2020-01-01 00:00:00'),
            lt(tabela.posts.criado_em, '2030-12-31 23:59:59')
        ))
    .innerJoin(tabela.usuarios, eq(tabela.usuarios.id, tabela.posts.usuario_id))
    .orderBy(desc(tabela.posts.criado_em));

console.log(consulta);</code></pre>
            </td>
            <td>
                <pre><code>[
  { titulo: 'primeiro artigo', nome: 'maria_silva' },
  { titulo: 'segundo artigo', nome: 'francisca_pereira' },
  { titulo: 'terceiro artigo', nome: 'francisca_pereira' },
  { titulo: 'quarto artigo', nome: 'maria_silva' },
  { titulo: 'quinto artigo', nome: 'francisca_pereira' }
]</code></pre>
            </td>
        </tr>
    </tbody>
</table>

<h3>Obtendo um único item</h3>
<p>Especialmente quando buscamos um objeto pela chave primária, sabemos que o resultado sempre será um único objeto. Porém o <code>select</code> sempre retorna uma lista, mesmo que seja uma lista de um único item.</p>
<table class="custom">
    <thead>
        <tr>
            <th>Código</th>
            <th>Saída</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>
                <pre><code>const lista = await db.select().from(tabela.usuarios)
.where(eq(tabela.usuarios.id, 2)).limit(1);

console.log(lista);
console.log(lista[0].nome);</code></pre>
            </td>
            <td>
                <pre><code>[
  {
    id: 2,
    nome: 'francisca_pereira',
    email: 'francisca@pereira.com',
    nascimento: '2002-11-05',
    pontos: 0,
    criado_em: '2025-03-31 16:45:03'
  }
]
francisca_pereira</code></pre>
            </td>
        </tr>
    </tbody>
</table>

<p>Em casos que você precisa apenas de um único item, ou do primeiro item da lista, você pode usar a <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring">sintaxe de desestruturação</a> do JavaScript:</p>
<table class="custom">
    <thead>
        <tr>
            <th>Código</th>
            <th>Saída</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>
                <pre><code>const [usuario] = await db.select().from(tabela.usuarios)
.where(eq(tabela.usuarios.id, 2)).limit(1);

console.log(usuario);
console.log(usuario.nome);</code></pre>
            </td>
            <td>
                <pre><code>{
  id: 2,
  nome: 'francisca_pereira',
  email: 'francisca@pereira.com',
  nascimento: '2002-11-05',
  pontos: 0,
  criado_em: '2025-03-31 16:45:03'
}
francisca_pereira</code></pre>
            </td>
        </tr>
    </tbody>
</table>

<h2>Inserções</h2>

<h3>Inserindo objetos ou listas de objetos</h3>
<p>Podemos inserir um objeto apenas...</p>
<pre><code>const pessoa = { nome: 'antonia_rodrigues', email: 'antonia@rodrigues.com' }
await db.insert(tabela.usuarios).values(pessoa);</code></pre>

<p>... Ou uma lista de objetos:</p>
<pre><code>const pessoas = [
    { nome: 'adriana_lima', email: 'adriana@lima.com' },
    { nome: 'luiz_alves', email: 'luiz@alves.com' }
]
await db.insert(tabela.usuarios).values(pessoas);</code></pre>

<h3>Nomes de propriedades abreviados</h3>
<p>Podemos inserir dados na tabela vindos de variáveis:</p>
<pre><code>const nome_usuario = 'francisco_ferreira'
const email_usuario = 'francisco@ferreira.com'
await db.insert(tabela.usuarios).values({ nome: nome_usuario, email: email_usuario, });</code></pre>

<p>Em muitos casos, o atributo do objeto e a variável têm o mesmo nome:</p>
<pre><code>const nome = 'francisco_ferreira'
const email = 'francisco@ferreira.com'
await db.insert(tabela.usuarios).values({ nome: nome, email: email, });</code></pre>

<p>Nesses casos, podemos usar a sintaxe de <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Object_initializer#property_definitions">nomes de propriedades abreviados</a>:</p>
<pre><code>const nome = 'francisco_ferreira'
const email = 'francisco@ferreira.com'
await db.insert(tabela.usuarios).values({ nome, email, });</code></pre>

<h3>Retornando o resultado</h3>
<p>Normalmente quando inserimos um objeto no banco, mas não informamos o ID, que é gerado automaticamente pelo banco. Em muitas situações, precisamos do ID gerado pelo banco. Para essas situações, podemos usar o método <code>returning</code>, que retorna o objeto recém inserido, já com o id gerado:</p>

<table class="custom">
    <thead>
        <tr>
            <th>Código</th>
            <th>Saída</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>
                <pre><code>const usuario = {
    nome: 'marcia_nascimento',
    email: 'marcia@nascimento.com'
}

const [novoUsuario] = await db
.insert(tabela.usuarios).values(usuario).returning();

console.log("Antes:", usuario);
console.log("Depois:", novoUsuario);</code></pre>
            </td>
            <td>
                <pre><code>Antes: {
    nome: 'marcia_nascimento',
    email: 'marcia@nascimento.com'
}

Depois: {
  id: 6,
  nome: 'marcia_nascimento',
  email: 'marcia@nascimento.com',
  nascimento: null,
  pontos: 0,
  criado_em: '2025-04-04 13:28:47'
}</code></pre>
            </td>
        </tr>
    </tbody>
</table>

<p>Geralmente, quando inserimos um objeto, como os outros atributos já temos, podemos querer apenas os atributos que são gerados pelo banco. Podemos filtrar quais atributos queremos retornar ao inserir:</p>

<table class="custom">
    <thead>
        <tr>
            <th>Código</th>
            <th>Saída</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>
                <pre><code>const usuario = { nome: 'carlos_gomes', email: 'carlos@gomes.com' }

const [criado] = await db.insert(tabela.usuarios)
    .values(usuario).returning({
        id: tabela.usuarios.id,
        criacao: tabela.usuarios.criado_em
    });

console.log("Usuário criado:", criado);</code></pre>
            </td>
            <td>
                <pre><code>Usuário criado: { id: 7, criacao: '2025-04-04 15:10:06' }</code></pre>
            </td>
        </tr>
    </tbody>
</table>

<p>Quando precisamso apenas do ID, este ainda seria retornado dentro de um objeto. Podemos usar a <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring">sintaxe de desestruturação</a> para obter apenas o ID do objeto retornado:</p>
<table class="custom">
    <thead>
        <tr>
            <th>Código</th>
            <th>Saída</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>
                <pre><code>const usuario = { nome: 'juliany_jesus', email: 'juliana@jesus.com' }

const [{ id }] = await db.insert(tabela.usuarios)
.values(usuario).returning({ id: tabela.usuarios.id });

console.log("ID:", id);</code></pre>
            </td>
            <td>
                <pre><code>ID: 8</code></pre>
            </td>
        </tr>
    </tbody>
</table>

<h2>Atualizações</h2>
<p>Atualizações são muito parecidas com consultas. Os seguintes trechos fazem a mesma coisa:</p>
<table class="custom align-left">
    <thead>
        <tr>
            <th>Código</th>
            <th>Situação</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>
                <pre><code>const nome = 'marcia_nascimento';
const pontuacao = 50;
const data_nascimento = '2003-04-05';

await db.update(tabela.usuarios)
    .set({ pontos: pontuacao, nascimento: data_nascimento })
    .where(eq(tabela.usuarios.nome, nome));</code></pre>
            </td>
            <td>Dados vindos de um formulário ou função.</td>
        </tr>
        <tr>
            <td>
                <pre><code>const nome: 'marcia_nascimento';
const pontos = 50;
const nascimento = '2003-04-05';

await db.update(tabela.usuarios)
    .set({ pontos, nascimento })
    .where(eq(tabela.usuarios.nome, nome));</code></pre>
            </td>
            <td>Dados vindos de um formulário ou função, e coincidem com os atributos do objeto.</td>
        </tr>
        <tr>
            <td>
                <pre><code>const usuario = {
    nome: 'marcia_nascimento',
    email: 'marcia@nascimento.com',
    pontos: 50, nascimento: '2003-04-05'
};

await db.update(tabela.usuarios).set(usuario)
    .where(eq(tabela.usuarios.nome, usuario.nome));</code></pre>
            </td>
            <td>Você tem os campos de atualização agrupados, ou já tinha o objeto e modificou alguns atributos.</td>
        </tr>
        <tr>
            <td>
                <pre><code>await db.update(tabela.usuarios).set({
    pontos: 50,
    nascimento: '2003-04-05'
}).where(eq(tabela.usuarios.nome, 'marcia_nascimento'));</code></pre>
            </td>
            <td>Rápido e direto. Usado geralmente em scripts de teste ou em pequenos ajustes no banco durante o início do projeto.</td>
        </tr>
    </tbody>
</table>

<h2>Inserções ou atualizações</h2>
<p>Se tentarmos inserir um objeto com um valor exclusivo (<em>unique</em>) ou chave primária já existente no banco, ocorrerá um erro. Por exemplo, Se existir alguém com email <code>juliana@jesus.com</code> no banco e tentarmos fazer essa operação:</p>
<pre><code>const pessoa = { nome: 'juliana_jesus', email: 'juliana@jesus.com' }
await db.insert(tabela.usuarios).values(pessoa);</code></pre>
<p>Ocorrerá o erro <code>SQLITE_CONSTRAINT_UNIQUE: UNIQUE constraint failed: usuarios.email</code>.</p>
<p>O DrizzleORM suporta a operação <code>onConflictDoNothing</code>, que cancela a inserção se houver um conflito:</p>
<pre><code>const pessoa = { nome: 'juliana_jesus', email: 'juliana@jesus.com' }
await db.insert(tabela.usuarios).values(pessoa).onConflictDoNothing();

// delimita quais atributos não conflitarão
await db.insert(tabela.usuarios).values(pessoa)
.onConflictDoNothing({ target: tabela.usuarios.email });</code></pre>

<p>O DrizzleORM também suporta a operação <code>onConflictDoUpdate</code>, que primeiramente tenta inserir um objeto, mas se já houver um objeto com algum dos campos, então atualiza ele:</p>

<table class="custom">
    <thead>
        <tr>
            <th>Código</th>
            <th>Saída</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>
                <pre><code>// busca um objeto
const [usuarioExistente] = await db.select().from(tabela.usuarios)
    .where(like(tabela.usuarios.nome, 'julian%'));

console.log('Antes da atualização:', usuarioExistente);

// atualiza o objeto
usuarioExistente.nome = 'juliana_jesus';
usuarioExistente.pontos = 150;

// salva o objeto
const [usuarioAtualizado] = await db.insert(tabela.usuarios)
    .values(usuarioExistente).onConflictDoUpdate({
        target: tabela.usuarios.email,
        set: usuarioExistente
    }).returning();

console.log('Depois da atualização:', usuarioAtualizado);</code></pre>
            </td>
            <td>
                <pre><code>Antes da atualização: {
  id: 7,
  nome: 'juliany_jesus',
  email: 'juliana@jesus.com',
  nascimento: null,
  pontos: 0,
  criado_em: '2025-04-08 11:04:54'
}
Depois da atualização: {
  id: 7,
  nome: 'juliana_jesus',
  email: 'juliana@jesus.com',
  nascimento: null,
  pontos: 150,
  criado_em: '2025-04-08 11:04:54'
}</code></pre>
            </td>
        </tr>
    </tbody>
</table>
<p>O <code>onConflictDoUpdate</code> exige que você indique qual coluna ou lista de colunas está causando o conflito (atributo <code>target</code>), e o que deve ser atualizado em caso de conflito (atributo <code>set</code>).</p>

<h2>Exclusões</h2>
<p>Tome muito cuidado com exclusões! Nunca faça algo do tipo:</p>
<pre><del>await db.delete(users);</del></pre>

<p>Ao excluir, você deve filtrar o que deve ser excluído:</p>
<pre><code>const id = 1
await db.delete(tabela.posts).where(eq(tabela.posts.id, id));
</code></pre>

<p>Se precisar, pode retornar o objeto excluído:</p>
<table class="custom">
    <thead>
        <tr>
            <th>Código</th>
            <th>Saída</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>
                <pre><code>const id = 4
const [postagemExcluida] = await db.delete(tabela.posts).where(eq(tabela.posts.id, id)).returning();
console.log(postagemExcluida);</code></pre>
            </td>
            <td>
                <pre><code>{
  id: 2,
  titulo: 'segundo artigo',
  conteudo: 'conteúdo do segundo artigo',
  usuario_id: 2,
  criado_em: '2025-04-09 21:12:48',
  atualizado_em: '2025-04-09 21:12:48'
}</code></pre>
            </td>
        </tr>
    </tbody>
</table>

<h2 id="operador-magico-de-sql">O operador mágico <code>sql</code></h2>
<p> Ao utilizar uma biblioteca ORM, pode haver situações em que escrever determinada consulta usando apenas a sintaxe da biblioteca se torna desafiador. Nesses casos, é comum recorrer às <strong>consultas brutas</strong> (<em>raw queries</em>), construídas como strings de SQL puro. No entanto, esse tipo de abordagem geralmente <strong>não oferece os benefícios da segurança de tipos</strong> nem da <strong>parametrização</strong>.</p>
<p> Para contornar esse problema, muitas bibliotecas introduziram o conceito de <strong>template SQL</strong>. Esse recurso permite escrever consultas de forma mais segura e flexível, com suporte a <strong>tipagem estática</strong> e <strong>parâmetros protegidos contra injeção de SQL</strong>. O <strong>DrizzleORM</strong>, por sua vez, oferece suporte nativo a esse modelo por meio do <a href="https://orm.drizzle.team/docs/sql">template <code>sql</code></a>.</p>
<p>Você pode utilizar o template <code>sql</code> do Drizzle de forma seletiva em trechos específicos da consulta, caso não seja possível escrevê-la completamente com a API do Drizzle. Isso significa que é possível usar o template <code>sql</code> em cláusulas como <code>SELECT</code>, <code>WHERE</code>, <code>ORDER BY</code>, <code>HAVING</code>, <code>GROUP BY</code> e até mesmo em consultas relacionais.</p>
<p>Ao adotar o template <code>sql</code>, você mantém as vantagens de segurança de tipos e de parametrização, sem abrir mão da flexibilidade necessária para construir consultas mais complexas. Entretanto, esse recurso só deve ser utilizado quando não for possível realizar uma operação usando a própria API do Drizzle, o que seria em casos raros.</p>
<p>Por exemplo, uma consulta bruta por todos os títulos das postagens de um usuário que começa com determinado nome seria:</p>

<table class="custom">
    <thead>
        <tr>
            <th>Código</th>
            <th>Saída</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>
                <pre><code>const nome = 'francisca';
const result = await db.all(
    sql`
    SELECT ${tabela.posts.titulo}
    FROM ${tabela.usuarios}
    INNER JOIN ${tabela.posts}
    ON ${tabela.usuarios.id} = ${tabela.posts.usuario_id}
    WHERE ${tabela.usuarios.nome} LIKE ${nome + '%'}
    `
);
console.log(result);</code></pre>
            </td>
            <td>
                <pre><code>[
  { titulo: 'segundo artigo' }, 
  { titulo: 'terceiro artigo' },
  { titulo: 'quinto artigo' }   
]</code></pre>
            </td>
        </tr>
    </tbody>
</table>

<p>No lugar de <code>db.all</code>, você pode usar <code>db.get</code> caso queira um resultado com apenas um item, ou <code>db.run</code> que traz informações mais detalhadas da consulta.</p>

<h2>Conclusão</h2>
<p>muito mais coisas dá pra fazer com DrizzleORM, como a api de consultas personalizada <a href='https://orm.drizzle.team/docs/rqb'><code>query</code></a>. se vc precisar fazer algo que não foi dito aqui, pode ser que já tenha um comando para o que você estiver precisando. neste caso, recomendo <a href="https://orm.drizzle.team/docs/overview">consultar a documentação</a> e procurar o que deseja.</p>
