<!DOCTYPE html>

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
  <script src="https://unpkg.com/highlightjs-svelte/dist/svelte.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlightjs-line-numbers.js/2.9.0/highlightjs-line-numbers.min.js"></script>
  <script defer>hljs.configure({ languages: ["svelte"] }); hljs.highlightAll(); hljs.initLineNumbersOnLoad();</script>

  <!-- https://github.com/arronhunt/highlightjs-copy -->
  <link rel="stylesheet" href="https://unpkg.com/highlightjs-copy/dist/highlightjs-copy.min.css" />
  <script src="https://unpkg.com/highlightjs-copy/dist/highlightjs-copy.min.js"></script>
  <script defer>hljs.addPlugin(new CopyButtonPlugin());</script>

  <!-- https://github.com/TRSasasusu/highlightjs-highlight-lines.js -->
  <script src="https://cdn.jsdelivr.net/gh/TRSasasusu/highlightjs-highlight-lines.js@1.2.0/highlightjs-highlight-lines.min.js"></script>
  <script defer>hljs.highlightLinesAll([[], [], [], [], [], [], [{ start: 1, end: 1, color: 'lightgreen' }, { start: 2, end: 2, color: 'lightblue' }], [], [], [], [], [], [], [], [], [], [], [], [{ start: 2, end: 2, color: 'lightblue' }, { start: 5, end: 5, color: 'lightblue' }, { start: 8, end: 10, color: 'lightblue' }]]);
  </script>

  <!-- <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css" integrity="sha384-n8MVd4RsNIU0tAv4ct0nTaAbDJwPJzDEaqSD1odI+WdtXRGWt2kTvGFasHpSy3SV" crossorigin="anonymous">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js" integrity="sha384-XjKyOOlGwcjNTAIQHIpgOno0Hl1YQqzUOEleOLALmuqehneUG+vnGctmUb0ZY0l8" crossorigin="anonymous"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js" integrity="sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05" crossorigin="anonymous" onload="renderMathInElement(document.body,{delimiters:[{left: '$$', right: '$$', display: true},{left: '$', right: '$', display: false}]});"></script> -->

  <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/pedrosiqueira/custom-style/custom.min.css">
  <script src="https://cdn.jsdelivr.net/gh/pedrosiqueira/custom-style/custom.min.js"></script>
</head>

<h1 id="carregando-dados-no-sveltekit">Carregando Dados do Servidor</h1>
<sub><a target="_blank" href="https://svelte.dev/docs/kit/load">Adaptado daqui</a>.</sub>
<p>Antes que um componente <code>+page.svelte</code> (e seus componentes <code>+layout.svelte</code> correspondentes) possa ser renderizado, frequentemente precisamos obter alguns dados. Isso é feito definindo funções <code>load</code>.</p>

<h2 id="dados-da-página">Dados da Página</h2>

<p>Um arquivo <code>+page.svelte</code> pode ter um arquivo irmão <code>+page.server.js</code>, que será executado no servidor antes de abrir a página no cliente. Esse arquivo exporta uma função <code>load</code>. O valor retornado por essa função estará disponível para a página através da propriedade <code>data</code>.</p>
<p>Crie o arquivo <code ctc>src/routes/03/test/+page.server.js</code>:</p>
<pre><code class="language-javascript">export function load() {
  return {
    post: { title: 'Título de Exemplo', content: 'Conteúdo &lt;b&gt;supimpa&lt;/b&gt; de Exemplo' },
    author: { name: 'Autor Exemplo', email: 'autor@exemplo.com' }
  };
}</code></pre>
<p>Crie o arquivo <code ctc>src/routes/03/test/+page.svelte</code>:</p>
<pre><code class="language-svelte">&lt;script&gt;
  let { data } = $props();
&lt;/script&gt;

&lt;h1&gt;{data.post.title}&lt;/h1&gt;
&lt;sub&gt;por {data.author.name}&lt;/sub&gt;
&lt;div&gt;{@html data.post.content}&lt;/div&gt;</code></pre>
<p id="load-return"><strong>Explicação:</strong> A função <code>load</code> em <code>+page.server.js</code> retorna um objeto com os dados necessários para a página. Esses dados são acessados no componente Svelte através da propriedade <code>data</code>.</p>

<h2 id="dados-do-layout">Dados do Layout</h2>

<p>Teus arquivos <code>+layout.svelte</code> também podem carregar dados, via <code>+layout.server.js</code>.</p>
<p>Crie o arquivo <code ctc>src/lib/server/postsDatabase.js</code>:</p>
<pre id="postsdatabase"><code class="language-javascript">const posts = [
  { slug: 'um', title: 'Primeiro Post', publish_date: '2025-03-12', content: 'Conteúdo do primeiro post' },
  { slug: 'outro', title: 'Outro Post', publish_date: '2025-03-25', content: 'Conteúdo do outro post' },
  { slug: 'algum', title: 'Mais um Post', publish_date: '2024-11-22', content: 'Conteúdo de mais um post' },
  { slug: 'ainda', title: 'Ainda Outro Post', publish_date: '2024-11-02', content: 'Conteúdo de ainda outro post' }
];

export function getAll(){ }
export function getByYearMonth(year, month){ }
export function getBySlug(slug){ }
export function getByQuery(title, content){ }</code></pre>
<p><strong>Explicação</strong>: Este arquivo simula um banco de dados de posts. Ele armazena um conjunto de dados em memória e define funções para acessar esses dados. No momento, as funções estão declaradas mas ainda não foram implementadas — essa será a tua tarefa.</p>
<div class="info">Atenção: Esse é um banco de dados apenas para fins didáticos! No mundo real, nossos dados ficariam em um banco de dados de verdade.</div>
<p>Crie o arquivo <code ctc>src/routes/03/posts/+layout.server.js</code>:</p>
<pre><code class="language-javascript">import * as postsDatabase from '$lib/server/postsDatabase';

export async function load() {
  const posts = postsDatabase.getAll();
  return { posts };
}</code></pre>
<p>A função <code>getAll()</code> ainda não existe no arquivo <code>src/lib/server/postsDatabase.js</code>. Será tua tarefa implementá-la, bem como todas as outras funções ainda não implementadas.</p>
<p>Crie o arquivo <code ctc>src/routes/03/posts/+layout.svelte</code>:</p>
<pre><code class="language-svelte">&lt;script&gt;
  let { data, children } = $props();
&lt;/script&gt;

&lt;div class=&quot;row&quot;&gt;
  &lt;div class=&quot;col-4 bg-body-secondary&quot;&gt;
    &lt;aside&gt;
      &lt;h4&gt;Últimos Posts&lt;/h4&gt;
      &lt;ul&gt;
        {#each data.posts.slice(0, 2) as post}
          &lt;li&gt;
            &lt;a href=&quot;/03/posts/{post.slug}&quot;&gt;
              {post.title}
            &lt;/a&gt;
          &lt;/li&gt;
        {/each}
      &lt;/ul&gt;
    &lt;/aside&gt;
  &lt;/div&gt;
  &lt;div class=&quot;col&quot;&gt;
    &lt;main&gt;
      {@render children()}
    &lt;/main&gt;
  &lt;/div&gt;
&lt;/div&gt;</code></pre>
<p><strong>Explicação:</strong> Dados retornados pela função <code>load</code> de um arquivo <code>+layout.server.js</code> ficam disponíveis para todos os seus componentes <code>.svelte</code> filhos, bem como para ele próprio. Aqui, o arquivo <code>+layout.server.js</code> carrega todos os posts e os disponibiliza para o layout e suas páginas filhas. No layout, exibimos os dois posts mais recentes em um menu lateral.</p>
<p>Vamos criar uma página filha. Crie o arquivo <code ctc>src/routes/03/posts/+page.svelte</code>:</p>
<pre><code class="language-svelte">&lt;script&gt;
  let { data } = $props();
&lt;/script&gt;

&lt;h3&gt;Todos os Posts&lt;/h3&gt;
{#each data.posts as post}
  &lt;p&gt;&lt;a href=&quot;/03/posts/{post.slug}&quot;&gt;{post.title}&lt;/a&gt;&lt;/p&gt;
{/each}</code></pre>
<p><strong>Explicação:</strong> A página principal lista todos os posts disponíveis, utilizando os dados fornecidos pelo layout.</p>
<div class="info">
  <p><strong>Nota:</strong> Se múltiplas funções <code>load</code> retornarem dados com a mesma propriedade, a última sobrescreve as anteriores. Por exemplo, se uma função <code>load</code> do layout retorna <code>{ a: 1, b: 2 }</code> e a da página retorna <code>{ b: 3, c: 4 }</code>, o resultado final será <code>{ a: 1, b: 3, c: 4 }</code>.</p>
</div>

<h2 id="load-params">Parâmetros da Função <code>load</code></h2>
<p>A função <code>load</code> recebe um objeto do tipo <a target="_blank" href="https://svelte.dev/docs/kit/@sveltejs-kit#ServerLoadEvent" id="serverloadevent">ServerLoadEvent</a> como argumento. Esse objeto contém várias propriedades úteis, como <code>params</code>, <code>url</code>, <code>fetch</code>, entre outras.</p>
<p>Para verificar o conteúdo desse objeto, altere o arquivo <code>src/routes/03/test/+page.server.js</code>:</p>
<pre><code>export function load(event) {
  console.log(event);
  return {
    post: {
      title: 'Título de Exemplo',
      content: 'Conteúdo <b>supimpa</b> de Exemplo'
    },
    author: {
      name: 'Autor Exemplo',
      email: 'autor@exemplo.com'
    }
  };
}</code></pre>
<p><strong>Explicação:</strong></p>
<p>Neste exemplo, estamos exibindo no terminal do servidor todas as propriedades do objeto <code>event</code>, que representa a requisição feita para essa página. Ao acessar a URL correspondente, observe o terminal para verificar as informações registradas.</p>
<div class="info">
  <h4>Anatomia de uma URL</h4>
  <pre>    https://meusite.com/uma/pagina?p1=123&p2=oi
    11111   22222222222 3333333333 444444444444
protocolo   domínio     parâmetros parâmetros  
                        de rota    de consulta
  </pre>
  <p>Os parâmetros de rota (route params) também podem ser chamados de parâmetros de caminho (path params).</p>
  <p>Os parâmetros de consulta (query params) também podem ser chamados de parâmetros de busca (search params).</p>
  <p>Exemplo de uma URL real:</p>
  <p class="text-center"><a target="_blank" href="https://www.youtube.com/watch?v=TiT7TlAWDEs&list=PLcZDQl73nB1ACZdEAd_wNbY0tB_QutcH3&index=2&t=60s&ab_channel=PedroHenriquedeAraujoSiqueira">
      <pre>https://
www.youtube.com
/watch
?v=TiT7TlAWDEs
&list=PLcZDQl73nB1ACZdEAd_wNbY0tB_QutcH3
&index=2
&t=360s
&ab_channel=PedroHenriquedeAraujoSiqueira</pre>
    </a></p>
</div>
<h3 id="params">params</h3>

<p>Uma rota pode ser um caminho estático, como <code>src/routes/about</code>, ou um caminho dinâmico, como <code>src/routes/blog/[slug]</code> ou <code>src/routes/posts/[ano]/[mes]</code>. Neste caso, <code>[slug]</code>, <code>[ano]</code> e <code>[mes]</code> são chamados de <strong>parâmetros de rota</strong>, ou seja, variáveis que permitem diferentes valores levarem à mesma página.</p>
<p>Por exemplo:</p>
<ul>
  <li>A URL <code>/about</code> abrirá a página em <code>src/routes/about</code>.</li>
  <li>As URLs <code>/blog/post1</code> e <code>/blog/post2</code> abrirão a mesma página dinâmica em <code>src/routes/blog/[slug]</code>, sendo que o valor de <code>slug</code> será <code>post1</code> ou <code>post2</code>, respectivamente.</li>
  <li>Da mesma forma, <code>/posts/2025/03</code> e <code>/posts/2024/11</code> abrirão a página <code>src/routes/posts/[ano]/[mes]</code>, com <code>ano</code> sendo <code>2025</code> ou <code>2024</code>, e <code>mes</code> sendo <code>03</code> ou <code>11</code>.</li>
</ul>
<ol class="excs">
  <h4>Exercícios de fixação</h4>
  <li>Ligue as URLs da esquerda às rotas da direita:
    <pre>https://meusite.com/blog              (a)
https://meusite.com/sobre             (b)
https://meusite.com/blog/[slug]       (c)
https://meusite.com/blog/artigo       (d)           (1) src/routes/about
https://meusite.com/slug              (e)           (2) src/routes/blog
https://meusite.com/blog/2025/03      (f)           (3) src/routes/blog/[slug]
https://meusite.com/2025/03           (g)           (4) src/routes/blog/[ano]/[mes]
https://meusite.com/blog/2025         (h)           (5) "erro 404"
https://meusite.com/blog/outro/artigo (i)
https://meusite.com/blog/about        (j)
https://meusite.com/blog/2025/03/01   (k)</pre>
  </li>
</ol>
<p>A propriedade <code>params</code> é um <strong>objeto</strong> onde cada propriedade corresponde ao nome do parâmetro definido entre colchetes na rota, e seu valor corresponde ao trecho da URL acessada.</p>
<p>Crie o arquivo <code ctc>src/routes/03/posts/[ano]/[mes]/+page.server.js</code>:</p>
<pre><code class="language-javascript">import * as postsDatabase from '$lib/server/postsDatabase';

export async function load({ params }) {
  const posts = postsDatabase.getByYearMonth(params.ano, params.mes);
  return { posts, ano: params.ano, mes: params.mes };
}</code></pre>
<p>Crie o arquivo <code ctc>src/routes/03/posts/[ano]/[mes]/+page.svelte</code>:</p>
<pre><code class="language-svelte">&lt;script&gt;
  let { data } = $props();
&lt;/script&gt;

&lt;h3&gt;Postagens de {data.mes}/{data.ano}&lt;/h3&gt;

{#each data.posts as post}
  &lt;p&gt;&lt;a href=&quot;/03/posts/{post.slug}&quot;&gt;{post.title}&lt;/a&gt;&lt;/p&gt;
{:else}
  &lt;p&gt;Nenhuma postagem nesse m&ecirc;s!&lt;/p&gt;
{/each}</code></pre>
<p><strong>Explicação:</strong> Utilizamos os parâmetros de rota <code>ano</code> e <code>mes</code> para filtrar os posts por data.</p>
<p>Também podemos implementar uma única página para exibir cada post separadamente.</p>
<p>Crie o arquivo <code ctc>src/routes/03/posts/[slug]/+page.server.js</code>:</p>
<pre><code class="language-javascript">import * as postsDatabase from '$lib/server/postsDatabase';

export async function load({ params }) {
  const post = postsDatabase.getBySlug(params.slug);
  return { post };
}</code></pre>
<p>Crie o arquivo <code ctc>src/routes/03/posts/[slug]/+page.svelte</code>:</p>
<pre><code class="language-svelte">&lt;script&gt;
  let { data } = $props();
&lt;/script&gt;

&lt;h1&gt;{data.post.title}&lt;/h1&gt;
&lt;sub&gt;Em {data.post.publish_date}&lt;/sub&gt;
&lt;p&gt;{data.post.content}&lt;/p&gt;</code></pre>
<p><strong>Explicação:</strong> Aqui, utilizamos o parâmetro de rota <code>slug</code> para buscar e exibir um post específico.</p>

<h3 id="url">url</h3>

<p>Além dos <strong>parâmetros de rota</strong>, também podemos passar informações pela <strong>URL</strong> usando o que chamamos de <strong>parâmetros de consulta</strong> — também conhecidos como <strong>query params</strong> ou <strong>search params</strong>.</p>
<p>Esses parâmetros aparecem após o símbolo <code>?</code> na URL. Por exemplo:</p>
<pre><code>https://meusite.com/produtos?categoria=livros&amp;ordem=preco</code></pre>
<p>Nesse caso, a URL possui dois query params:</p>
<ul>
  <li><code>categoria</code> com valor <code>&quot;livros&quot;</code></li>
  <li><code>ordem</code> com valor <code>&quot;preco&quot;</code></li>
</ul>
<p>No SvelteKit, dentro da função <code>load</code>, você pode acessar esses dados através da propriedade <code>url</code>, que é um objeto do tipo <a target="_blank" href="https://developer.mozilla.org/en-US/docs/Web/API/URL">URL</a>. Esse objeto representa a URL da requisição e contém várias informações úteis, como:</p>
<ul>
  <li><code>origin</code>: origem da URL (ex: <code>https://meusite.com</code>)</li>
  <li><code>pathname</code>: caminho da URL (ex: <code>/produtos</code>)</li>
  <li><code>searchParams</code>: um objeto do tipo <a target="_blank" href="https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams">URLSearchParams</a>, que representa os parâmetros de consulta da URL e permite acessar facilmente os valores dos query params.</li>
</ul>
<p>Crie o arquivo <code ctc>src/routes/03/posts/query/+page.server.js</code>:</p>
<pre><code class="language-javascript">import * as postsDatabase from '$lib/server/postsDatabase';

export async function load({ url }) {
  console.log(url);
  const title = url.searchParams.get('title') || null;
  const content = url.searchParams.get('content') || null;

  if (!title && !content) return { posts: postsDatabase.getAll() };

  return { posts: postsDatabase.getByQuery(title, content) };
}</code></pre>
<div class="info">
  <p>💡 <strong>Dica:</strong> Neste exemplo, usamos <code>console.log()</code> para exibir o conteúdo da URL e dos parâmetros no terminal ou no console do navegador. Essa é uma ferramenta muito útil para <strong>debugar</strong> (ou seja, investigar e entender o que está acontecendo no seu código).</p>
  <p>Sempre que estiver em dúvida sobre o que uma variável contém, experimente usar <code>console.log(minhaVariavel)</code> para visualizar seu valor. Isso pode ajudar bastante na hora de identificar problemas e entender melhor o fluxo do programa.</p>
</div>
<p>Crie o arquivo <code ctc>src/routes/03/posts/query/+page.svelte</code>:</p>
<pre><code class="language-svelte">&lt;script&gt;
  let { data } = $props();
&lt;/script&gt;

&lt;form&gt;
  &lt;input type=&quot;text&quot; name=&quot;title&quot; placeholder=&quot;Busca por título...&quot; /&gt;
  &lt;input type=&quot;text&quot; name=&quot;content&quot; placeholder=&quot;Busca por conteúdo...&quot; /&gt;
  &lt;button type=&quot;submit&quot;&gt;Buscar&lt;/button&gt;
&lt;/form&gt;

&lt;h1&gt;Busca de posts&lt;/h1&gt;

&lt;ul&gt;
  {#each data.posts as post}
    &lt;li&gt;&lt;a href=&quot;/03/posts/{post.slug}&quot;&gt;{post.title}&lt;/a&gt;&lt;/li&gt;
  {:else}
    &lt;li&gt;Nenhum resultado encontrado.&lt;/li&gt;
  {/each}
&lt;/ul&gt;</code></pre>
<p><strong>Explicação:</strong> Neste exemplo, a função <code>load</code> acessa os parâmetros da URL usando <code>url.searchParams.get('termo')</code>, permitindo buscar posts por título. Isso simula uma funcionalidade de busca baseada em query strings.</p>
<h4>Exercícios de fixação</h4>
<ol class="excs">
  <li>Considere os seguintes arquivos:
    <p><code>src/routes/03/[p1]/[p2]/+page.server.js</code>:</p>
    <pre><code class="language-js">export async function load({ params, url }) {
    const rp1 = params.p1;
    const rp2 = params.p2;
    const sp1 = url.searchParams.get('p1');
    const sp2 = url.searchParams.get('p2');

    return { rp1, rp2, sp1, sp2 };
}</code></pre>
    <p><code>src/routes/03/[p1]/[p2]/+page.svelte</code>:</p>
    <pre><code class="language-html">&lt;script&gt;
  let { data } = $props();
&lt;/script&gt;

&lt;p&gt;Parâmetros de rota:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;{data.rp1}&lt;/li&gt;&lt;li&gt;{data.rp2}&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;Parâmetros de busca:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;{data.sp1}&lt;/li&gt;&lt;li&gt;{data.sp2}&lt;/li&gt;&lt;/ul&gt;</code></pre>
    <p>O que aparece na tela para cada uma das seguintes URLs?</p>
    <ol type="a">
      <li>https://meusite.com/03/uma/pagina?p1=123&amp;p2=oi</li>
      <li>https://meusite.com/03/123/oi?p1=uma&amp;p2=pagina</li>
      <li>https://meusite.com/03/outra/url?p1=td_blz&amp;p2=ok</li>
      <li>https://meusite.com/03/uma/pagina</li>
      <li>https://meusite.com/03/uma/outra/pagina</li>
      <li>https://meusite.com/03/uma/pagina?p1=123&amp;q4=567</li>
      <li>https://meusite.com/03/p1/123?p2=567</li>
    </ol>
  </li>
</ol>
<h3 id="fetch">fetch</h3>

<p>Para buscar dados de uma API externa ou de teu próprio servidor, você pode usar a função <code>fetch</code> disponibilizada pelo SvelteKit. Ela se comporta de forma idêntica à API nativa <code>fetch</code>, mas com algumas vantagens:</p>
<ul>
  <li>Pode ser usada para fazer requisições autenticadas no servidor, herdando cookies e cabeçalhos de autorização da requisição da página.</li>
  <li>Requisições internas (como para rotas <code>+server.js</code>) são redirecionadas diretamente para o manipulador de requisições no servidor, sem a sobrecarga de uma chamada HTTP.</li>
  <li>Em alguns casos, é mais eficiente, pois <a target="_blank" href="https://svelte.dev/docs/kit/load#Making-fetch-requests">evita uma requisição adicional</a>.</li>
</ul>
<p>Crie o arquivo <code ctc>src/routes/03/external/users/+page.server.js</code>:</p>
<pre><code class="language-js">export async function load({ fetch }) {
  const res = await fetch('https://jsonplaceholder.typicode.com/users');
  const users = await res.json();
  return { users };
}</code></pre>
<p><strong>Explicação:</strong> Esse código faz uma requisição para a API externa <a target="_blank" href="https://jsonplaceholder.typicode.com/">JSONPlaceholder</a> e retorna os dados dos usuários. Como está em <code>+page.server.js</code>, a requisição sempre será feita no servidor, protegendo eventuais dados sensíveis.</p>
<p>Crie o arquivo <code ctc>src/routes/03/external/users/+page.svelte</code>:</p>
<pre><code class="language-svelte">&lt;script&gt;
  let { data } = $props();
&lt;/script&gt;

&lt;h3&gt;Usuários&lt;/h3&gt;
&lt;ul&gt;
  {#each data.users as user}
    &lt;li&gt;&lt;a href=&quot;/03/external/users/{user.id}&quot;&gt;{user.name}&lt;/a&gt;&lt;/li&gt;
  {/each}
&lt;/ul&gt;</code></pre>
<p><strong>Explicação:</strong> Aqui, iteramos sobre os usuários carregados e mostramos uma lista com links para cada um.</p>
<p>Agora vamos carregar as informações de um usuários, bem como suas postagens. Crie o arquivo <code ctc>src/routes/03/external/users/[id]/+page.server.js</code>:</p>
<pre><code class="language-js">export async function load({ params, fetch }) {
  const resUser = await fetch(`https://jsonplaceholder.typicode.com/users/${params.id}`);
  const user = await resUser.json();

  const resPosts = await fetch(`https://jsonplaceholder.typicode.com/users/${params.id}/posts`);
  const posts = await resPosts.json();

  return { user, posts };
}</code></pre>
<p><strong>Explicação:</strong> Usamos <code>params.id</code> para buscar os dados de um usuário específico e também suas postagens. Retornamos tudo no objeto <code>data</code>.</p>
<p>Crie o arquivo <code ctc>src/routes/03/external/users/[id]/+page.svelte</code>:</p>
<pre><code class="language-svelte">&lt;script&gt;
  let { data } = $props();
&lt;/script&gt;

&lt;h3&gt;User&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Nome:&lt;/strong&gt; {data.user.name}&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Email:&lt;/strong&gt; {data.user.email}&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Telefone:&lt;/strong&gt; {data.user.phone}&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Website:&lt;/strong&gt; {data.user.website}&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Companhia:&lt;/strong&gt; {data.user.company.name}&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Endereço:&lt;/strong&gt; {data.user.address.street}, {data.user.address.suite}, {data.user.address.city}, {data.user.address.zipcode}&lt;/p&gt;

&lt;h3&gt;Postagens do usuário&lt;/h3&gt;
&lt;ul&gt;
  {#each data.posts as post}
    &lt;li&gt;&lt;a href=&quot;/03/external/posts/{post.id}&quot;&gt;{post.title}&lt;/a&gt;&lt;/li&gt;
  {:else}
    &lt;p&gt;Esse usuário não postou nada ainda!&lt;/p&gt;
  {/each}
&lt;/ul&gt;
&lt;p&gt;
  &lt;a href=&quot;/03/external/users&quot;&gt;Voltar aos usuários&lt;/a&gt;
&lt;/p&gt;</code></pre>
<p><strong>Explicação:</strong></p>
<ul>
  <li>Este componente exibe os dados completos de um usuário, incluindo nome, email, telefone, site, empresa e endereço formatado.</li>
  <li>Abaixo das informações pessoais, é exibida a lista de postagens associadas ao usuário.</li>
  <li>Se o usuário não tiver nenhuma postagem, uma mensagem informativa será exibida no lugar da lista.</li>
  <li id="post-id">Os títulos das postagens são links que direcionam para a rota <code>/03/external/posts/{post.id}</code>, que ainda deverá ser implementada.</li>
  <li>No final da página, há um link para retornar à lista geral de usuários.</li>
</ul>
<h2 id="pagedata">page.data</h2>

<p>O componente <code>+page.svelte</code>, assim como cada <code>+layout.svelte</code> acima dele na hierarquia, tem acesso aos seus próprios dados e também aos dados de todos os seus layouts &quot;pais&quot;.</p>
<p>No entanto, em algumas situações precisamos do contrário — um layout &quot;pai&quot; pode precisar acessar dados carregados por uma página ou por um layout &quot;filho&quot;. Um exemplo comum é o layout raiz (<code>+layout.svelte</code>) querer acessar uma propriedade <code>title</code> retornada pela função <code>load</code> de um <code>+page.server.js</code>.</p>
<p>Para isso, utilizamos <a target="_blank" href="https://svelte.dev/docs/kit/$app-state#page">page.data</a>.</p>
<p><strong>Modifique</strong> o arquivo <code ctc>src/routes/03/posts/+layout.svelte</code>:</p>
<pre><code class="language-svelte">&lt;script&gt;
  import { page } from '$app/state';
  let { data, children } = $props();

  console.log(page);
&lt;/script&gt;

&lt;svelte:head&gt;
  &lt;title&gt;{page.data.post?.title || page.url.pathname}&lt;/title&gt;
&lt;/svelte:head&gt;

&lt;div class=&quot;row&quot;&gt;
  &lt;div class=&quot;col-4 bg-body-secondary&quot;&gt;
    &lt;aside&gt;
      &lt;h4&gt;Últimos posts&lt;/h4&gt;
      &lt;ul&gt;
        {#each data.posts.slice(0, 2) as post}
          &lt;li&gt;
            &lt;a href=&quot;/03/posts/{post.slug}&quot;&gt;
              {post.title}
            &lt;/a&gt;
          &lt;/li&gt;
        {/each}
      &lt;/ul&gt;
    &lt;/aside&gt;
  &lt;/div&gt;
  &lt;div class=&quot;col&quot;&gt;
    &lt;main&gt;
      {@render children()}
    &lt;/main&gt;
  &lt;/div&gt;
&lt;/div&gt;</code></pre>
<p><strong>Explicação:</strong> Aqui, o layout acessa <code>page.data.post?.title</code> para definir o título da aba dinamicamente com base na página carregada.</p>

<h4>Exercícios de fixação</h4>
<ol class="excs">
  <li>Considere os dois arquivos seguintes:
    <p><code>src/routes/uva/[jaca]/pera/+page.svelte</code>:</p>
    <pre><code class="language-svelte">&lt;script&gt;
  import { page } from '$app/state';
&lt;/script&gt;
{page.params.jaca}
</code></pre>
    <p><code>src/routes/uva/jaca/[pera]/+page.svelte</code>:</p>
    <pre><code class="language-svelte">&lt;script&gt;
  import { page } from '$app/state';
&lt;/script&gt;
{page.params.pera}
</code></pre>
    <p>O que aparecerá na tela ao acessar cada uma das seguintes URLs?</p>
    <ul>
      <li>/jaca</li>
      <li>/jaca/uva/pera</li>
      <li>/uva</li>
      <li>/uva/caju/jaca</li>
      <li>/uva/figo/caqui</li>
      <li>/uva/jaca</li>
      <li>/uva/jaca/caju</li>
      <li>/uva/jaca/pera</li>
      <li>/uva/kiwi/pera</li>
      <li>/uva/pera/jaca</li>
      <li>/uva/pera/kiwi</li>
    </ul>
  </li>
</ol>

<h2 id="cliente-vs-servidor">Cliente vs Servidor</h2>

<p>Além das funções <code>load</code> nos arquivos <code>+layout.server.js</code> e <code>+page.server.js</code>, que sempre são executadas no servidor, também existem as funções <code>load</code> nos arquivos <code>+layout.js</code> e <code>+page.js</code>, conhecidas como funções <code>load</code> universais. Essas funções podem ser executadas tanto no servidor quanto no navegador (a menos que sejam combinadas com <code>export const ssr = false</code>, caso em que elas serão executadas <a target="_blank" href="https://svelte.dev/docs/kit/page-options#ssr">somente no navegador</a>).</p>
<p>Por padrão, as funções <code>load</code> universais são executadas no servidor durante o SSR (Server-Side Rendering) quando o usuário visita a página pela primeira vez. Elas serão executadas novamente durante o processo de <a target="_blank" href="https://svelte.dev/docs/kit/glossary#Hydration">hidratação</a>, reutilizando quaisquer respostas de <a target="_blank" href="https://svelte.dev/docs/kit/load#Making-fetch-requests">requisições fetch</a> feitas anteriormente. Todas as invocações subsequentes dessas funções <code>load</code> universais ocorrerão no navegador. Você pode personalizar esse comportamento por meio das <a target="_blank" href="https://svelte.dev/docs/kit/page-options">opções da página</a>. Por exemplo, se desativar a opção de página <a target="_blank" href="https://svelte.dev/docs/kit/page-options#ssr">server-side rendering</a>, você estará criando uma SPA (Single Page Application), e todas as funções <code>load</code> universais serão executadas no cliente.</p>
<p>Se uma rota contiver tanto funções <code>load</code> universais quanto funções <code>load</code> específicas para o servidor, a função <code>load</code> do servidor será executada primeiro.</p>
<p>A função <code>load</code> é invocada em tempo de execução, a menos que você <a target="_blank" href="https://svelte.dev/docs/kit/page-options#prerender">pré-renderize</a> a página — nesse caso, ela será invocada em tempo de compilação.</p>

<h3 id="quando-usar-cada-tipo">Quando usar o quê</h3>
<ul>
  <li>
    <p>Se a sua função <code>load</code> deve ser executada sempre no servidor, por exemplo, quando utiliza variáveis de ambiente privadas ou acessa um banco de dados ou sistema de arquivos, ela deve ser colocada em um <code>+page.server.js</code>.</p>
  </li>
  <li>
    <p>Como o SvelteKit pode acessar os dados diretamente da API sem passar pelo seu servidor, se você precisar buscar dados de uma API externa e não precisar de credenciais privadas, use o <code>+page.js</code>.</p>
  </li>
</ul>

<h2 id="conclusão">Conclusão</h2>

<p>O SvelteKit oferece uma série de recursos poderosos para carregar dados de maneira eficiente, seja do servidor, de APIs externas ou de fontes internas. Ao entender as diferenças entre as funções <code>load</code> nos arquivos <code>+page.server.js</code>, <code>+layout.server.js</code>, <code>+page.js</code> e <code>+layout.js</code>, você pode otimizar o desempenho de teu aplicativo, aproveitando o que há de melhor em renderização no servidor e no cliente. Para explorar mais sobre esses recursos e como aplicá-los, consulte a <a target="_blank" href="https://svelte.dev/docs/kit/load">documentação oficial</a>.</p>

<h2 id="exercícios">Exercícios</h2>

<ol class="excs">
  <li><strong>Implemente as seguintes funções</strong> <a href="#postsdatabase">no arquivo <code>postsDatabase.js</code></a>, responsáveis por manipular os dados dos posts: <ol>
      <li><code>getAll()</code>: Retorna todos os posts cadastrados.</li>
      <li><code>getByYearMonth(year, month)</code>: Retorna os posts publicados no ano e mês especificados.</li>
      <li><code>getBySlug(slug)</code>: Retorna o post que corresponde exatamente ao <code>slug</code> fornecido.</li>
      <li><code>getByQuery(title, content)</code>: Retorna todos os posts cujo título contenha a string fornecida em <code>title</code> ou cujo conteúdo contenha a string em <code>content</code>. A busca não deve diferenciar maiúsculas de minúsculas. Campos vazios, nulos ou indefinidos não devem ser considerados no filtro.</li>
    </ol>
  </li>
  <li><strong>Implemente a <a href="#post-id">rota faltante</a></strong> <code class="ctc">src/routes/03/external/posts/[id]</code>, que exibe a postagem com o <code>id</code> especificado da API REST <a target="_blank" href="https://jsonplaceholder.typicode.com/">JSONPlaceholder</a>.</li>
  <li><strong>Deixe seu aplicativo SvelteKit totalmente navegável.</strong> Garanta que todas as rotas criadas possam ser acessadas por meio de links. Para isso: <ul>
      <li>Crie os arquivos correspondentes indicados neste capítulo.</li>
      <li>Adicione os links ao menu de navegação lateral.</li>
    </ul>
  </li>
  <li><strong>Consuma a API REST da <a target="_blank" href="https://pokeapi.co/">PokéAPI</a></strong> para criar uma página que liste os Pokémons. Cada item da lista deve conter um link para a página de detalhes do respectivo Pokémon.</li>
  <p><strong>Possível solução:</strong></p>
  <p>Crie o arquivo <code ctc>src/routes/03/pokemon/+page.svelte</code></p>
  <pre><code class="language-svelte">&lt;script&gt;
  let { data } = $props();
&lt;/script&gt;

&lt;div class="row"&gt;
  {#each data.pokemons as p}
    &lt;div class="col-md-3 col-sm-6 mb-3"&gt;
      &lt;div class="card"&gt;
        &lt;img src={p.image} alt={p.name} class="card-img-top" /&gt;
        &lt;div class="card-body"&gt;
          &lt;a href="/03/pokemon/{p.name}" class="stretched-link text-decoration-none"&gt;
            &lt;h5 class="card-title text-capitalize"&gt;{p.name}&lt;/h5&gt;
          &lt;/a&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  {/each}
&lt;/div&gt;</code></pre>
  <p><strong>Explicação:</strong></p>
  <ul>
    <li>O código acima exibe uma grade de cards com os Pokémons listados.</li>
    <li><strong>Linha 8</strong>: Cada <a target="_blank" href="https://getbootstrap.com/docs/5.3/components/card/#images">card</a> é colocado em uma coluna que ocupa largura 3/12 em telas médias pra cima (<code>col-md-3</code>), e largura 6/12 em telas pequenas pra cima (<code>col-sm-6</code>), e ocupa 100% da largura em telas menores.</li>
    <li><strong>Linha 11:</strong> O link direciona para uma página com mais informações sobre o Pokémon.</li>
    <li><strong>Linha 11:</strong> A classe <a target="_blank" href="https://getbootstrap.com/docs/5.3/helpers/stretched-link/"><code>stretched-link</code></a> permite que a área inteira do card seja clicável.</li>
  </ul>
  <p><strong>Carregando os dados:</strong></p>
  <p>Crie o arquivo <code ctc>src/routes/03/pokemon/+page.js</code>:</p>
  <pre><code class="language-js">export async function load() {
  const limit = 12;
  const offset = 0;

  const res = await fetch(`https://pokeapi.co/api/v2/pokemon?offset=${offset}&limit=${limit}`);
  const data = await res.json();

  for (const pokemon of data.results) {
    const id = pokemon.url.split("/").at(-2);
    pokemon.image = `https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/${id}.png`;
  }

  return { pokemons: data.results };
}</code></pre>
  <p><strong>Explicação:</strong></p>
  <ul>
    <li><strong>Linhas 2 e 3:</strong> Define os parâmetros para buscar apenas 12 pokémons (<code>limit = 12</code>) a partir do início (<code>offset = 0</code>).</li>
    <li><strong>Linha 5:</strong> Faz uma requisição para a PokéAPI, pedindo os 12 primeiros pokémons.</li>
    <li><strong>Linha 6:</strong> A resposta recebida contém apenas os nomes e as URLs dos pokémons, sem trazer diretamente as imagens.</li>
    <li><strong>Linhas 8 a 10:</strong> Para cada pokémon na lista, extraímos o seu ID da URL. Como a URL tem um formato como <code>https://pokeapi.co/api/v2/pokemon/6/</code>, usamos:
      <ul>
        <li><code>split("/")</code> para transformar a URL em uma lista de partes separadas por <code>/</code>;</li>
        <li><code>at(-2)</code> para acessar o penúltimo item da lista, que corresponde ao ID do pokémon. Isso funciona porque as URLs da PokéAPI terminam com uma barra, deixando o ID na posição anterior à última barra.</li>
      </ul>
      <p>Esse ID é então usado para montar a URL da imagem correspondente, disponível no repositório da PokéAPI no GitHub como <code>https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/6.png</code></p>
    </li>

    <li><strong>Linha 13:</strong> Retorna a lista de pokémons (agora com imagens adicionadas) para ser utilizada pela interface do SvelteKit.</li>
  </ul>
  <p>Essa abordagem é comum quando a API retorna informações parciais. Em vez de fazer uma nova requisição para trazer a imagem de cada pokémon (o que seria mais lento), deduzimos o ID e montamos a URL direto para o repositório de imagens — uma solução prática e eficiente.</p>
  <li><strong>Implemente a paginação</strong> para a listagem dos Pokémons. <p><strong>Passos sugeridos:</strong></p>
    <ol>
      <li>Exiba um número limitado de Pokémons por página (ex: 20).</li>
      <li>Adicione botões "Próximo" e "Anterior" para navegar entre as páginas.</li>
      <li>Ao clicar em um botão de navegação, a página será atualizada com os novos itens da próxima ou da página anterior.</li>
      <li>Teste a funcionalidade para garantir que a navegação funcione corretamente.</li>
    </ol>
  </li>
  <li><strong>Adicione uma funcionalidade de busca</strong> para filtrar Pokémons com base em parâmetros de consulta (query params) (por exemplo, tipo, nome etc.).</li>
  <li><strong>Crie uma página de detalhes</strong> para cada Pokémon. Essa página será acessada ao clicar em um Pokémon na lista.</li>
</ol>