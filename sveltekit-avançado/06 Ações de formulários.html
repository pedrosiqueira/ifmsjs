<!DOCTYPE html>

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
  <script src="https://unpkg.com/highlightjs-svelte/dist/svelte.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlightjs-line-numbers.js/2.9.0/highlightjs-line-numbers.min.js"></script>
  <script defer>hljs.configure({ languages: ["svelte"] }); hljs.highlightAll(); hljs.initLineNumbersOnLoad();</script>

  <!-- https://github.com/arronhunt/highlightjs-copy -->
  <link rel="stylesheet" href="https://unpkg.com/highlightjs-copy/dist/highlightjs-copy.min.css" />
  <script src="https://unpkg.com/highlightjs-copy/dist/highlightjs-copy.min.js"></script>
  <script defer>hljs.addPlugin(new CopyButtonPlugin());</script>

  <!-- https://github.com/TRSasasusu/highlightjs-highlight-lines.js -->
  <!-- <script src="https://cdn.jsdelivr.net/gh/TRSasasusu/highlightjs-highlight-lines.js@1.2.0/highlightjs-highlight-lines.min.js"></script>
  <script defer>hljs.highlightLinesAll([[], [], [], [], [], [],
    [{ start: 1, end: 1, color: 'lightblue' }, { start: 7, end: 8, color: 'lightgreen' }, { start: 9, end: 13, color: 'lightblue' }],
    [{ start: 1, end: 3, color: 'lightblue' }, { start: 14, end: 19, color: 'lightblue' }],
    [{ start: 13, end: 21, color: 'lightblue' }, { start: 24, end: 27, color: 'lightblue' }],
    [{ start: 8, end: 9, color: 'lightgreen' }, { start: 14, end: 19, color: 'lightblue' }],
    [{ start: 1, end: 1, color: 'lightgreen' }, { start: 5, end: 6, color: 'lightgreen' }, { start: 7, end: 18, color: 'lightblue' }],
    ]);
  </script> -->

  <!-- <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css" integrity="sha384-n8MVd4RsNIU0tAv4ct0nTaAbDJwPJzDEaqSD1odI+WdtXRGWt2kTvGFasHpSy3SV" crossorigin="anonymous">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js" integrity="sha384-XjKyOOlGwcjNTAIQHIpgOno0Hl1YQqzUOEleOLALmuqehneUG+vnGctmUb0ZY0l8" crossorigin="anonymous"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js" integrity="sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05" crossorigin="anonymous" onload="renderMathInElement(document.body,{delimiters:[{left: '$$', right: '$$', display: true},{left: '$', right: '$', display: false}]});"></script> -->

  <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/pedrosiqueira/custom-style/custom.min.css">
  <script src="https://cdn.jsdelivr.net/gh/pedrosiqueira/custom-style/custom.min.js"></script>
</head>

<h1>Ações de Formulário</h1>

<h2>Tipos de Requisições HTTP</h2>
<p>O protocolo HTTP define vários métodos (ou "verbos") de requisição que um cliente pode enviar a um servidor. Até agora, usamos apenas requisições <strong>GET</strong> para buscar dados do servidor (via <code>load</code>). Para enviar dados do navegador para o servidor (criar, atualizar ou excluir informações), usaremos requisições <strong>POST</strong> (e, posteriormente, outros métodos como PUT e DELETE). Este capítulo aborda as <strong>ações de formulário</strong> com POST, permitindo envio seguro de dados, evitando exposição na URL e possibilitando retornos personalizados (sucesso/erro).</p>

<table class="custom">
  <thead>
    <tr>
      <th>Método</th>
      <th>Descrição</th>
      <th>Dados</th>
      <th>Características</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>GET</strong></td>
      <td>Solicita um recurso (página HTML, dados JSON, etc.).</td>
      <td>Parâmetros na URL (query string). Sem corpo (body).</td>
      <td>Idempotente: não deve alterar o estado do servidor e múltiplas requisições idênticas devem retornar o mesmo resultado.</td>
    </tr>
    <tr>
      <td><strong>POST</strong></td>
      <td>Envia dados para criar ou processar um recurso (envio de formulário, etc.).</td>
      <td>Dados no corpo (body): campos de formulário, JSON, etc.</td>
      <td>Não é idempotente: múltiplas requisições podem criar vários recursos ou causar alterações distintas.</td>
    </tr>
  </tbody>
</table>

<img src="./cliente-servidor.png" alt="uma imagem de um cliente enviando dois tipos de cartas ao servidor, uma carta GET, que só possui o envelope, com o endereço do destinatário como uma url; e uma carta POST, que possui uma mensagem dentro do envelope, além do endereço.">

<h2>Enviando Dados com GET</h2>
<p>Como vimos no capítulo <a target="_blank" href="./03 Carregando dados do servidor.html">Carregando dados do servidor</a>, requisições GET enviam dados pela URL. O elemento <code>&lt;form&gt;</code> é o principal recurso da web para enviar informações do cliente para o servidor. Por padrão, o formulário usa o método <code>GET</code>, que não possui corpo e torna as informações visíveis na URL, apresentando <a target="_blank" href="../sveltekit/0D Protocolo HTTP.html#desvantagens">várias desvantagens</a>.</p>

<p>Crie o arquivo <code ctc>src/routes/06/get/+page.svelte</code>:</p>
<pre><code class="language-svelte">&lt;script&gt;
  let { data } = $props();
&lt;/script&gt;

&lt;form&gt;
  &lt;input name="email" type="email" placeholder="E-mail de usuário" /&gt;
  &lt;input name="senha" type="password" placeholder="Senha" /&gt;
  &lt;button&gt;Entrar&lt;/button&gt;
&lt;/form&gt;

{#if data.status == 400}
  &lt;p&gt;E-mail e senha são obrigatórios!&lt;/p&gt;
{:else if data.status == 401}
  &lt;p&gt;Usuário ou senha inválidos!&lt;/p&gt;
{:else if data.status == 200}
  &lt;p&gt;Login efetuado com sucesso!&lt;/p&gt;
  &lt;p&gt;Bem-vindo, {data.email}!&lt;/p&gt;
{/if}</code></pre>

<p>Crie o arquivo <code ctc>src/routes/06/get/+page.server.js</code>:</p>
<pre><code class="language-javascript">export async function load({ url }) {
  const email = url.searchParams.get('email');
  const senha = url.searchParams.get('senha');

  if (!email || !senha) return { status: 400 };
  if (senha !== '1234') return { status: 401 };

  return { status: 200, email };
}</code></pre>

<p><strong>Explicação:</strong> Ao submeter o formulário, os dados aparecem na URL. O servidor lê esses parâmetros em <code>load</code>, retorna um status, e a página exibe mensagens diferentes conforme o valor de <code>data.status</code>. Note que, neste exemplo, a senha fica visível na URL, o que é um problema de segurança!</p>

<h2>Ações Padrão (Default) com POST</h2>

<p>Para lidar com requisições <code>POST</code>, um arquivo <code>+page.server.js</code> pode exportar um objeto <code>actions</code>. As funções dentro de <code>actions</code> processam os dados enviados pelo formulário.</p>

<p>Crie o arquivo <code ctc>src/routes/06/post/+page.svelte</code>:</p>
<pre><code class="language-svelte">&lt;form method="POST"&gt;
  &lt;input name="email" type="email" placeholder="E-mail de usuário" /&gt;
  &lt;input name="senha" type="password" placeholder="Senha" /&gt;
  &lt;button&gt;Entrar&lt;/button&gt;
&lt;/form&gt;</code></pre>

<p><strong>Explicação:</strong></p>
<ul>
  <li>O atributo <code>method="POST"</code> especifica que o formulário usará o método POST para enviar os dados.</li>
  <li>Ao submeter, o formulário envia os dados para a URL atual (já que <code>action</code> não foi especificado).</li>
  <li>Isso aciona a ação <code>default</code> no arquivo <code>+page.server.js</code> correspondente.</li>
</ul>

<p>Crie o arquivo <code ctc>src/routes/06/post/+page.server.js</code>:</p>
<pre><code class="language-javascript">export const actions = {
  default: async (event) =&gt; {
    console.log(event);
    console.log(await event.request.formData());
  }
};</code></pre>

<p><strong>Explicação:</strong></p>
<ul>
  <li>A função <code>default</code> é executada quando a rota <code>/06/post</code> recebe uma requisição <code>POST</code>.</li>
  <li>O parâmetro <code>event</code> é um objeto <a target="_blank" href="https://svelte.dev/docs/kit/@sveltejs-kit#RequestEvent">RequestEvent</a>, contendo informações da requisição.</li>
  <li>Como vimos no <a target="_blank" href="./03 Carregando dados do servidor.html#serverloadevent">capítulo anterior</a>, a função <code>load</code> recebe um objeto <a target="_blank" href="https://svelte.dev/docs/kit/@sveltejs-kit#ServerLoadEvent">ServerLoadEvent</a>, que herda os métodos de <code>RequestEvent</code>. Por isso, você já deve estar familiarizado com propriedades como <code>params</code>, <code>url</code> e <code>fetch</code>, disponíveis tanto em ações de formulário quanto na função <code>load</code>.</li>
  <li>Para acessar os dados enviados pelo formulário, utilize o método assíncrono <code>formData()</code> do objeto <a target="_blank" href="https://developer.mozilla.org/en-US/docs/Web/API/Request"><code>request</code></a>, que é uma propriedade de <code>event</code>.</li>
</ul>

<div class="info">
  <p><strong>Observação:</strong> Ações de formulário só respondem a requisições <code>POST</code>. Requisições <code>GET</code> não devem alterar o estado do servidor.</p>
</div>

<p>Você pode enviar dados para outra rota especificando o atributo <code>action</code> no formulário:</p>

<p>Crie o arquivo <code ctc>src/routes/06/form/+page.svelte</code>:</p>
<pre><code class="language-svelte">&lt;form method="POST" action="/06/post"&gt;
  &lt;input type="number" placeholder="Digite um número" /&gt;
  &lt;input name="umtexto" placeholder="Digite um texto" /&gt;
  &lt;input name="umadata" type="date" /&gt;
  &lt;button&gt;Enviar&lt;/button&gt;
&lt;/form&gt;</code></pre>

<p><strong>Explicação:</strong> O atributo <code>action="/06/post"</code> faz com que este formulário envie os dados para a ação padrão da rota <code>/06/post</code>.</p>

<div class="info">
  <p><strong>Observação:</strong> O atributo <code>name</code> é essencial para que o valor de um campo seja incluído na requisição. No exemplo acima, o valor do campo numérico (sem <code>name</code>) não será enviado.</p>
</div>

<p>Ótimo! Agora temos um meio eficiente e seguro de trocar dados entre páginas!</p>

<h2>Retornando Dados da Ação</h2>

<p>Após processar a requisição, a ação pode retornar dados que ficam disponíveis na propriedade <code>form</code> da página Svelte correspondente. Os valores em <code>form</code> são persistentes, ficando disponíveis inclusive em <code>page.form</code> em todo o aplicativo, até a próxima atualização da página.</p>

<p>Modifique <code ctc>src/routes/06/post/+page.server.js</code>:</p>
<pre><code class="language-javascript">export const actions = {
  default: async ({ request }) =&gt; {
    const data = await request.formData();
    const email = data.get('email');
    const senha = data.get('senha');

    if (!email || !senha) return { status: 400 };
    if (senha !== '1234') return { status: 401 };

    return { status: 200, email };
  }
};</code></pre>

<p><strong>Explicação:</strong></p>
<ul>
  <li>Linha 2: Desestruturamos o objeto <code>event</code>, pois só precisamos da propriedade <code>request</code>.</li>
  <li>Linhas 3-5: Usamos <code>request.formData()</code> para obter os valores dos campos <code>email</code> e <code>senha</code>.</li>
  <li>Linhas 6-8: Se algum campo estiver vazio, retornamos <code>{ status: 400 }</code>. Se a senha estiver incorreta, retornamos <code>{ status: 401 }</code>. Caso contrário, retornamos <code>{ status: 200, email }</code>.</li>
</ul>

<p>Assim como os dados retornados por <code>load</code> <a target="_blank" href="./03 Carregando dados do servidor.html#load-return">ficam disponíveis</a> na propriedade <code>data</code>, os dados retornados por uma ação de formulário ficam disponíveis na propriedade <code>form</code>.</p>

<p>Agora, modifique <code ctc>src/routes/06/post/+page.svelte</code> para exibir esses dados:</p>
<pre><code class="language-svelte">&lt;script&gt;
  let { form } = $props();
&lt;/script&gt;

&lt;form method="POST"&gt;
  &lt;input name="email" type="email" placeholder="E-mail de usuário" /&gt;
  &lt;input name="senha" type="password" placeholder="Senha" /&gt;
  &lt;button&gt;Entrar&lt;/button&gt;
&lt;/form&gt;

{#if !form}
  &lt;p&gt;Preencha e submeta o formulário.&lt;/p&gt;
{:else if form.status == 400}
  &lt;p&gt;E-mail e senha são obrigatórios&lt;/p&gt;
{:else if form.status == 401}
  &lt;p&gt;Usuário ou senha inválidos&lt;/p&gt;
{:else if form.status == 200}
  &lt;p&gt;Login efetuado com sucesso!&lt;/p&gt;
  &lt;p&gt;Bem-vindo, {form.email}!&lt;/p&gt;
{/if}</code></pre>

<p><strong>Explicação:</strong></p>
<ul>
  <li>Linha 2: A propriedade <code>form</code> contém os dados retornados pela ação do formulário.</li>
  <li>Linha 11: Diferentemente de <code>load</code>, que sempre é executada ao acessar a rota, ações de formulário só são executadas após uma requisição <code>POST</code>. Portanto, <code>form</code> não existe se não houve submissão, e precisamos dessa verificação antes de acessar qualquer de suas propriedades.</li>
  <li>Se <code>form</code> existir, verificamos <code>form.status</code> e exibimos a mensagem correspondente.</li>
</ul>

<h2>Redirecionamentos</h2>

<p>Para redirecionar o usuário após uma ação, usamos a função <code>redirect(status, url)</code> de <code>@sveltejs/kit</code>. Essa função lança uma exceção que interrompe a execução da ação e responde com o código de redirecionamento especificado.</p>

<p>Modifique <code ctc>src/routes/06/post/+page.server.js</code>:</p>
<pre><code class="language-javascript">import { redirect } from '@sveltejs/kit';

export const actions = {
  default: async ({ request }) =&gt; {
    const data = await request.formData();
    const email = data.get('email');
    const senha = data.get('senha');

    if (!email || !senha) return { status: 400 };
    if (senha !== '1234') return { status: 401 };

    redirect(303, '/06/profile');
  }
};</code></pre>

<p><strong>Explicação:</strong></p>
<ul>
  <li>Importamos <code>redirect</code> de <code>@sveltejs/kit</code>.</li>
  <li id="profile">Se o login for bem-sucedido, redirecionamos o usuário para a rota <code>/06/profile</code> (que ainda não foi criada) com o código HTTP 303.</li>
</ul>

<div class="info">
  <p><strong>Observação:</strong> Toda resposta HTTP possui um código de status. Códigos 300–399 indicam redirecionamentos; 400–499, erros do cliente; 500–599, erros do servidor. Consulte a <a target="_blank" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status">documentação do MDN</a> para detalhes.</p>
</div>

<div class="info">
  <p><strong>Importante:</strong> <code>redirect()</code> lança uma exceção e encerra a execução da ação. Não coloque-o dentro de um bloco <code>try/catch</code>, pois isso impedirá o redirecionamento.</p>
</div>

<div class="info">
  <p><strong>Observação:</strong> Redirecionamentos também podem ser usados em <a target="_blank" href="https://svelte.dev/docs/kit/load#Redirects"><code>load</code></a>.</p>
</div>

<h2>Validação de Erros com <code>fail</code></h2>

<p>Se a requisição não puder ser processada devido a dados inválidos, é possível retornar mensagens de erro junto com os valores inseridos anteriormente. Isso permite que o usuário corrija os dados e tente novamente. A função <code>fail(status, data)</code> de <code>@sveltejs/kit</code> retorna um código HTTP (geralmente na faixa dos 400) e um objeto com dados como detalhes do erro e valores dos campos. O status fica disponível em <code>page.status</code> e os dados em <code>form</code>.</p>

<p>Modifique <code ctc>src/routes/06/post/+page.server.js</code>:</p>
<pre><code class="language-javascript">import { fail, redirect } from '@sveltejs/kit';

export const actions = {
  default: async ({ request }) =&gt; {
    const data = await request.formData();
    const email = data.get('email');
    const senha = data.get('senha');

    if (!email || !senha) return fail(400, { error: 'Email e senha são obrigatórios.', email });

    if (!email.includes('@')) return fail(400, { error: 'Email inválido.', email });

    if (senha.length &lt; 4) return fail(400, { error: 'A senha deve ter pelo menos 4 caracteres.', email });

    if (email == "email@inexistente") return fail(400, { error: 'Email ou senha inválidos.', email });

    redirect(303, '/06/profile');
  }
};</code></pre>

<p><strong>Explicação:</strong></p>
<ul>
  <li>Linhas 9–15: Validamos os dados. Se estiverem inválidos, usamos <code>fail</code> para retornar a mensagem de erro e manter os dados do formulário.</li>
  <li>Linha 11: A validação de email é simplificada. Em sistemas reais, utilize bibliotecas específicas e robustas para isso.</li>
  <li>Linha 15: Apenas para simular a situação de um email inexistente.</li>
</ul>

<p>Modifique <code ctc>src/routes/06/post/+page.svelte</code>:</p>
<pre><code class="language-svelte">&lt;script&gt;
  let { form } = $props();
&lt;/script&gt;

&lt;form method="POST"&gt;
  &lt;input name="email" type="email" placeholder="E-mail de usuário" value={form?.email || ''} required /&gt;
  &lt;input name="senha" type="password" placeholder="Senha" required /&gt;
  &lt;button&gt;Entrar&lt;/button&gt;
&lt;/form&gt;

{#if form?.error}
  &lt;p style="color: red"&gt;{form.error}&lt;/p&gt;
{/if}</code></pre>

<p><strong>Explicação:</strong></p>
<ul>
  <li>O campo e-mail mantém seu valor em caso de erro, para que o usuário não precise digitá-lo novamente.</li>
  <li>Por segurança, a senha não é preservada após um erro.</li>
  <li>Se houver erro, mostramos a mensagem apropriada.</li>
  <li>A validação no navegador (como <code>type="email"</code> e <code>required</code>) ajuda a evitar erros, mas a validação no servidor é indispensável, pois o código do cliente pode ser alterado pelo usuário. Para testar, inspecione o campo de e-mail, remova o atributo <code>type="email"</code> e tente enviar um endereço de e-mail inválido.</li>
</ul>

<div class="info">
  <p><strong>Observação:</strong> Na linha 6, <code>?.</code> é um <a target="_blank" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Optional_chaining">operador de encadeamento opcional</a>, que tenta acessar a propriedade <code>email</code> do objeto <code>form</code>. Se o objeto for indefinido ou nulo, a expressão entra em curto-circuito e é avaliada como <code>undefined</code> em vez de gerar um erro.</p>
  <p>O equivalente de <code>form?.email || ''</code> usando <a target="_blank" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Conditional_operator">operador ternário</a> seria <code>form? form.email : ''</code>, que significa: obtenha o <code>email</code> de <code>form</code>, caso exista, senão, obtenha uma string vazia.</p>
</div>

<h2 id="Named-actions">Ações Nomeadas</h2>

<p>Além da ação padrão, podemos declarar várias ações nomeadas em um mesmo arquivo <code>+page.server.js</code>. Cada ação é executada ao especificar <code>?/nomeDaAcao</code> em <code>action</code> ou em <code>formaction</code>.</p>

<p>Crie o arquivo <code ctc>src/routes/06/named/+page.server.js</code>:</p>
<pre><code class="language-javascript">import { fail } from '@sveltejs/kit';

export const actions = {
  multiplicar: async ({ request }) =&gt; {
    const data = await request.formData();
    const x = Number(data.get('x'));
    const y = Number(data.get('y'));

    if (isNaN(x) || isNaN(y)) return fail(400, { error: 'Informe números válidos.', x, y });

    return { result: x * y };
  },
  dividir: async ({ request }) =&gt; {
    const data = await request.formData();
    const x = Number(data.get('x'));
    const y = Number(data.get('y'));

        if (isNaN(x) || isNaN(y)) return fail(400, { error: 'Informe números válidos.', x, y });

        if (y == 0) return fail(400, { error: 'Não é possível dividir por zero!', x, y });

    return { result: x / y };
  }
};</code></pre>

<p><strong>Explicação:</strong></p>
<ul>
  <li>Definimos duas ações: <code>multiplicar</code> e <code>dividir</code>.</li>
  <li>Mesmo que os dados do formulário representem números, eles chegam como strings. Por isso, usamos a função <code>Number</code> para converter essas strings em valores numéricos.</li>
  <li>Realizamos validações para garantir que os dados convertidos sejam, de fato, números. Caso o usuário tenha digitado algo inválido, a função <code>Number</code> não conseguirá fazer a conversão, e <code>isNaN</code> (de <em>is not a number</em>) retornará <code>true</code>, indicando a entrada inválida.</li>
</ul>

<p>Crie o arquivo <code ctc>src/routes/06/named/+page.svelte</code>:</p>
<pre><code class="language-svelte">&lt;script&gt;
  let { form } = $props();
&lt;/script&gt;

&lt;form method="POST" action="?/multiplicar"&gt;
  &lt;label&gt;
    x: &lt;input name="x" type="number" step="0.01" value={form?.x ?? ''} required /&gt;
  &lt;/label&gt;
  &lt;br /&gt;
  &lt;label&gt;
    y: &lt;input name="y" type="number" step="0.01" value={form?.y ?? ''} required /&gt;
  &lt;/label&gt;
  &lt;br /&gt;
  &lt;button type="submit"&gt;Multiplicar&lt;/button&gt;
  &lt;button type="submit" formaction="?/dividir"&gt;Dividir&lt;/button&gt;
&lt;/form&gt;

{#if form &amp;&amp; form.error != undefined}
  &lt;p style="color: red"&gt;{form.error}&lt;/p&gt;
{/if}

{#if form &amp;&amp; form.result != undefined}
  &lt;p style="color: green"&gt;Resultado: {form.result}&lt;/p&gt;
{/if}</code></pre>

<p><strong>Explicação:</strong></p>
<ul>
  <li>O formulário usa <code>action="?/multiplicar"</code>, acionando a ação <code>multiplicar</code> por padrão.</li>
  <li>O botão "Dividir" usa <code>formaction="?/dividir"</code>, enviando o mesmo formulário para a ação <code>dividir</code>.</li>
  <li>Os valores de <code>form.x</code> e <code>form.y</code> são preservados em caso de erro para facilitar a correção.</li>
  <li>Se <code>form.error</code> existir, exibimos a mensagem de erro; se <code>form.result</code> existir, exibimos o resultado.</li>
</ul>

<p>Os atributos <code>action</code> e <code>formaction</code> recebem apenas um parâmetro de consulta como valor (por exemplo, <code>action="?/multiplicar"</code>), o que significa que o formulário será enviado para a mesma rota da URL atual. Caso fosse necessário enviar os dados para uma rota diferente, você poderia definir, por exemplo, <code>action="/outra/rota?/multiplicar"</code>.</p>

<div class="info">
  <p><strong>Atenção:</strong> Não é recomendável combinar ação padrão com ações nomeadas na mesma página. Se você submeter uma ação nomeada sem redirecionar, o parâmetro <code>?/acao</code> permanecerá na URL. Assim, uma próxima submissão para a ação padrão continuará sendo tratada pela última ação nomeada, o que pode causar comportamentos inesperados.</p>
</div>

<h2>GET vs POST</h2>
<p>Para invocar uma ação de formulário, é necessário usar <code>method="POST"</code>. Formulários com <code>method="GET"</code> (ou sem especificar) simplesmente navegam para a URL indicada, como se fosse um link (<code>&lt;a&gt;</code>), anexando os campos como parâmetros de consulta, e acionam apenas a função <code>load</code> da rota de destino – nada é enviado ao objeto <code>actions</code>. Exemplo:</p>

<pre><code class="language-svelte">&lt;form action="/search"&gt;
  &lt;label&gt;
    Pesquisa:
    &lt;input name="q" type="text" /&gt;
  &lt;/label&gt;
  &lt;button&gt;Buscar&lt;/button&gt;
&lt;/form&gt;</code></pre>

<p>Ao submeter, o navegador vai para <code>/search?q=...</code> usando GET e o SvelteKit executa <code>load</code> em <code>/search</code>, mas não aciona nenhuma ação de formulário.</p>

Veja as principais diferenças de tratamento entre as requisições GET e POST:

<table border>
  <thead>
    <tr>
      <th>Operação</th>
      <th>GET</th>
      <th>POST</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Quem recebe as requisições</td>
      <td>A função <code>load</code></td>
      <td>As funções do objeto <code>actions</code></td>
    </tr>
    <tr>
      <td>Como obter os dados do formulário</td>
      <td>Através do método <code>url.searchParams()</code></td>
      <td>Através do método <code>request.formData()</code></td>
    </tr>
    <tr>
      <td>Como os dados do servidor chegam até a página</td>
      <td>Através da variável <code>data</code></td>
      <td>Através da variável <code>form</code></td>
    </tr>
  </tbody>
</table>

<div class="info">Atenção: Mesmo uma requisição POST pode enviar parâmetros de consulta pela URL. Apesar de requisições GET também poderem enviar dados por um corpo, <a href="https://www.baeldung.com/cs/http-get-with-body">isso não ser recomendado</a>.</div>

<h2>Exercícios de Fixação</h2>
<ol>
  <li>Explique a diferença entre uma requisição GET e uma requisição POST em formulários HTML.</li>
  <li>Quando é mais vantajoso usar <code>POST</code> em vez de <code>GET</code> em formulários?</li>
  <li>Qual das opções abaixo representa um risco de segurança quando se usa GET para envio de formulários?
    <ol type="a">
      <li>Os dados são criptografados automaticamente.</li>
      <li>Os dados ficam visíveis na URL.</li>
      <li>O formulário não envia os dados.</li>
      <li>A requisição GET exige autenticação via token.</li>
    </ol>
  </li>
  <li>Complete: Requisições GET não devem causar _______ no servidor, enquanto requisições POST são usadas para _______ .</li>
  <li>O que acontece se você omitir o atributo <code>name</code> de um campo de formulário?</li>
  <li>Qual é o papel do objeto <code>event</code> em uma ação de formulário no SvelteKit? Cite ao menos duas propriedades úteis.</li>
  <li>Onde os dados retornados por uma ação de formulário ficam disponíveis na página?
    <ol type="a">
      <li><code>data</code></li>
      <li><code>event.params</code></li>
      <li><code>form</code></li>
      <li><code>load.formData</code></li>
    </ol>
  </li>
  <li>Observe este trecho:
    <pre><code class="language-js">export const actions = {
  default: async ({ request }) => {
    const data = await request.formData();
    const nome = data.get('nome');
    const idade = data.get('idade');
    if (!nome || !idade) return { status: 400 };
    return { status: 200, nome };
  }
};</code></pre>
    <ol type="a">
      <li>Quais são os dois campos obrigatórios esperados neste formulário?</li>
      <li>Qual valor será retornado se o campo "nome" estiver vazio?</li>
      <li>Onde os dados <code>status</code> e <code>nome</code> poderão ser usados na página <code>.svelte</code> correspondente?</p>
      </li>
    </ol>
  </li>
</ol>

<h2>Exercícios Práticos</h2>
<ol class="excs">
  <li>Crie a página <code ctc>src/routes/06/profile/+page.svelte</code> (mencionada <a href="#profile">anteriormente</a>) para exibir uma mensagem de boas-vindas com o email do usuário. Verifique se a rota <code>/06/post</code> redireciona corretamente para essa página após o login bem-sucedido.
  <p>Dica: você pode redirecionar para a página de boas vindas passando um parâmetro de consulta.</p>
  </li>
  <li>Considere a rota <code ctc>src/routes/06/teste</code>:
    <ol type="a">
      <li>Crie um formulário em <code>+page.svelte</code> que envie, via POST, um campo chamado <code>mensagem</code> para a mesma rota.</li>
      <li>Crie a ação <code>default</code> correspondente em <code>+page.server.js</code>. A ação deve retornar o texto da mensagem com status 200, ou status 400 caso o campo esteja vazio.</li>
      <li>Altere o <code>+page.svelte</code> para exibir uma mensagem diferente dependendo do status retornado.</li>
    </ol>
  </li>
  <li>Considere a rota <code ctc>src/routes/06/cadastro-produto</code>. Crie uma página com um formulário POST para cadastrar produtos com os seguintes campos: "nome do produto" (texto), "preço" (número decimal) e "quantidade em estoque" (número inteiro). Ao submeter o formulário, implemente as seguintes validações:
    <ul>
      <li>Se "nome" estiver vazio, retorne <code>fail(400, { error: 'Nome obrigatório.', nome, preco, quantidade })</code>.</li>
      <li>Se "preço" não for um número válido ou for ≤ 0, retorne <code>fail(400, { error: 'Preço inválido.', nome, preco, quantidade })</code>.</li>
      <li>Se "quantidade" não for um inteiro ≥ 1, retorne <code>fail(400, { error: 'Quantidade inválida.', nome, preco, quantidade })</code>.</li>
    </ul>
    <p>Apenas quando todos os campos forem válidos, retorne <code>{ sucesso: true, produto: nome }</code>.</p>
    <p>No componente, exiba o texto de erro (se houver) e mantenha os valores preenchidos nos campos. Se o cadastro for bem-sucedido, mostre "Produto {nome} cadastrado com sucesso!".</p>
  </li>
  <li>Crie um formulário de cadastro com os seguintes campos obrigatórios:
    <ul>
      <li><code>nome</code>: Mínimo de 2 caracteres.</li>
      <li><code>email</code>: Deve conter apenas letras, <code>@</code> e <code>.</code>, com pelo menos uma palavra antes do <code>@</code> e duas após, separadas pelo <code>.</code>.</li>
      <li><code>data de nascimento</code>: A idade deve ser ≥ 12 anos.</li>
    </ul>
    <p>Se houver erros:</p>
    <ul>
      <li>Use <code>fail</code> para retornar os dados preenchidos e mensagens de erro.</li>
      <li>Exiba os erros abaixo de cada campo no formulário.</li>
    </ul>
    <p>Se estiver tudo certo:</p>
    <ul>
      <li>Retorne <code>{ success: true, nome }</code> e exiba:
        <blockquote>
          <p>“Cadastro concluído com sucesso. Bem-vindo(a), {nome}!”</p>
        </blockquote>
      </li>
    </ul>
  </li>
  <li>Crie um formulário de pagamento com os seguintes campos obrigatórios:
    <ul>
      <li><code>nome no cartão</code>: Mínimo 3 letras.</li>
      <li><code>número do cartão</code>: 16 dígitos.</li>
      <li><code>data de validade</code>: formato MM/AA, data futura.</li>
      <li><code>código de segurança (CVV)</code>: 3 dígitos.</li>
      <li><code>plano</code>: Campo select com as opções: <code>Plano Bit (básico)</code>, <code>Plano Byte (intermediário)</code>, <code>Plano Quantum (premium)</code>.</li>
    </ul>
    <p>Se houver erros:</p>
    <ul>
      <li>Use <code>fail</code> para retornar os dados preenchidos e erros.</li>
      <li>Exiba os erros abaixo de cada campo no formulário.</li>
    </ul>
    <p>Se estiver tudo certo, redirecione para a página com base no plano:</p>
    <ul>
      <li><code>/04/ex2/basico</code></li>
      <li><code>/04/ex2/intermediario</code></li>
      <li><code>/04/ex2/premium</code></li>
    </ul>
    <p>Essas páginas devem mostrar informações (inventadas) sobre o plano, bem como:</p>
    <blockquote>
      <p>“Pagamento aprovado. Bem-vindo(a) ao Plano {X}!”</p>
    </blockquote>
  </li>
  <li>Recentemente, três novas irmandades abriram inscrições em seu reino de fantasia. Para se juntar a cada uma dessas irmandades, existem pré-requisitos específicos:
    <ul>
      <li><strong>Ordem dos Guerreiros</strong>: Mínimo de 18 anos; Força física ≥ 7 (escala de 1 a 10).</li>
      <li><strong>Círculo dos Magos</strong>: Mínimo de 16 anos; Inteligência ≥ 8; Possui "conhecimento de magia" (checkbox).</li>
      <li><strong>Guilda dos Artesãos</strong>: Mínimo de 15 anos; Habilidade manual ("destreza") ≥ 6; Possui "ferramentas de artesão" (checkbox).</li>
    </ul>
    <p>Crie uma página de inscrição que permita ao usuário tentar se registrar em qualquer uma das três irmandades:</p>
    <ul>
      <li>Cada botão do formulário deve acionar uma <strong>ação nomeada</strong> diferente, que validará os requisitos da irmandade correspondente.</li>
      <li>Se o usuário atender aos requisitos, a ação deve <strong>redirecionar</strong> para a página inicial da respectiva irmandade (que você também deverá implementar).</li>
      <li>Se faltar qualquer requisito, a ação deve retornar um erro via <code>fail()</code>, preservando os campos preenchidos e exibindo a mensagem de erro apropriada.</li>
    </ul>
    <p>Estrutura de Rotas:</p>
    <ul>
      <li><code>src/routes/06/irmandades/+page.svelte</code>: Página de inscrição.</li>
      <li><code>src/routes/06/irmandades/guerreiros/+page.svelte</code>: Página inicial dos guerreiros.</li>
      <li><code>src/routes/06/irmandades/magos/+page.svelte</code>: Página inicial dos magos.</li>
      <li><code>src/routes/06/irmandades/artesaos/+page.svelte</code>: Página inicial dos artesãos.</li>
    </ul>
  </li>
  <li>Você trabalha em um banco digital que oferece três tipos de empréstimo, cada um com pré-requisitos diferentes:
    <ul>
      <li><strong>Empréstimo Pessoal</strong>: Renda mensal ≥ R$ 2.000; Score de crédito ≥ 600.</li>
      <li><strong>Empréstimo Imobiliário</strong>: Renda mensal ≥ R$ 5.000; Score de crédito ≥ 700; Possui imóvel para garantia (checkbox).</li>
      <li><strong>Empréstimo Automotivo</strong>: Renda mensal ≥ R$ 3.000; Score de crédito ≥ 650; Valor do veículo ≥ R$ 15.000.</li>
    </ul>
    <p>Crie uma página de solicitação de empréstimo que permita ao usuário escolher qual modalidade deseja:</p>
    <ul>
      <li>Cada botão do formulário deve acionar uma <strong>ação nomeada</strong> diferente, que validará os requisitos da modalidade correspondente.</li>
      <li>Se o usuário atender aos requisitos, a ação deve <strong>redirecionar</strong> para a página de confirmação daquele tipo de empréstimo (que você também deverá implementar).</li>
      <li>Se faltar qualquer requisito, a ação deve retornar um erro via <code>fail()</code>, preservando os campos preenchidos e exibindo a mensagem de erro apropriada.</li>
    </ul>
    <p>Estrutura de Rotas:</p>
    <ul>
      <li><code>src/routes/06/emprestimo/+page.svelte</code>: Página de solicitação de empréstimo.</li>
      <li><code>src/routes/06/emprestimo/pessoal/+page.svelte</code>: Página de confirmação do empréstimo pessoal.</li>
      <li><code>src/routes/06/emprestimo/imobiliario/+page.svelte</code>: Página de confirmação do empréstimo imobiliário.</li>
      <li><code>src/routes/06/emprestimo/automotivo/+page.svelte</code>: Página de confirmação do empréstimo automotivo.</li>
    </ul>
  </li>
</ol>