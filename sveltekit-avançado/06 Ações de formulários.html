<!DOCTYPE html>

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
  <script src="https://unpkg.com/highlightjs-svelte/dist/svelte.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlightjs-line-numbers.js/2.9.0/highlightjs-line-numbers.min.js"></script>
  <script defer>hljs.configure({ languages: ["svelte"] }); hljs.highlightAll(); hljs.initLineNumbersOnLoad();</script>

  <!-- https://github.com/arronhunt/highlightjs-copy -->
  <link rel="stylesheet" href="https://unpkg.com/highlightjs-copy/dist/highlightjs-copy.min.css" />
  <script src="https://unpkg.com/highlightjs-copy/dist/highlightjs-copy.min.js"></script>
  <script defer>hljs.addPlugin(new CopyButtonPlugin());</script>

  <!-- https://github.com/TRSasasusu/highlightjs-highlight-lines.js -->
  <!-- <script src="https://cdn.jsdelivr.net/gh/TRSasasusu/highlightjs-highlight-lines.js@1.2.0/highlightjs-highlight-lines.min.js"></script>
  <script defer>hljs.highlightLinesAll([[], [], [], [], [], [],
    [{ start: 1, end: 1, color: 'lightblue' }, { start: 7, end: 8, color: 'lightgreen' }, { start: 9, end: 13, color: 'lightblue' }],
    [{ start: 1, end: 3, color: 'lightblue' }, { start: 14, end: 19, color: 'lightblue' }],
    [{ start: 13, end: 21, color: 'lightblue' }, { start: 24, end: 27, color: 'lightblue' }],
    [{ start: 8, end: 9, color: 'lightgreen' }, { start: 14, end: 19, color: 'lightblue' }],
    [{ start: 1, end: 1, color: 'lightgreen' }, { start: 5, end: 6, color: 'lightgreen' }, { start: 7, end: 18, color: 'lightblue' }],
    ]);
  </script> -->

  <!-- <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css" integrity="sha384-n8MVd4RsNIU0tAv4ct0nTaAbDJwPJzDEaqSD1odI+WdtXRGWt2kTvGFasHpSy3SV" crossorigin="anonymous">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js" integrity="sha384-XjKyOOlGwcjNTAIQHIpgOno0Hl1YQqzUOEleOLALmuqehneUG+vnGctmUb0ZY0l8" crossorigin="anonymous"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js" integrity="sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05" crossorigin="anonymous" onload="renderMathInElement(document.body,{delimiters:[{left: '$$', right: '$$', display: true},{left: '$', right: '$', display: false}]});"></script> -->

  <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/pedrosiqueira/custom-style/custom.min.css">
  <script src="https://cdn.jsdelivr.net/gh/pedrosiqueira/custom-style/custom.min.js"></script>
</head>

<h1>Ações de Formulário</h1>

<p>No capítulo <a target="_blank" href="./03 Carregando dados do servidor.html">Carregando dados do servidor</a>, vimos como enviar dados do servidor para o navegador. Muitas vezes, é necessário fazer o inverso — enviar dados do navegador para o servidor. Para isso, utilizamos o elemento <code>&lt;form&gt;</code>, o principal recurso da plataforma web para esse tipo de comunicação. No entanto, por padrão, o elemento <code>form</code> envia os dados para o servidor com o método HTTP GET, que não possui corpo: os dados ficam visíveis na URL, o que possui <a target="_blank" href="../sveltekit/0D Protocolo HTTP.html#desvantagens">várias desvantagens</a>...</p>
<p>Crie o arquivo <code ctc>src/routes/06/get/+page.svelte</code>:</p>
<pre><code class="svelte">&lt;script&gt;
  let { data } = $props();
&lt;/script&gt;

&lt;form&gt;
  &lt;input name="email" type="email" placeholder="E-mail de usuário" /&gt;
  &lt;input name="senha" type="password" placeholder="Senha" /&gt;
  &lt;button&gt;Entrar&lt;/button&gt;
&lt;/form&gt;
{#if data.status == 400}
  &lt;p&gt;E-mail e senha são obrigatórios&lt;/p&gt;
{:else if data.status == 401}
  &lt;p&gt;Usuário ou senha inválidos&lt;/p&gt;
{:else if data.status == 200}
  &lt;p&gt;Login efetuado com sucesso!&lt;/p&gt;
  &lt;p&gt;Bem-vindo, {data.email}!&lt;/p&gt;
{/if}</code></pre>
<p>Crie o arquivo <code ctc>src/routes/06/get/+page.server.js</code>:</p>
<pre><code class="js">export async function load({ url }) {
    const email = url.searchParams.get('email');
    const senha = url.searchParams.get('senha');
    if (!email || !senha) return { status: 400 };
    if (senha !== '1234') return { status: 401 };
    return { status: 200, email };
}</code></pre>

<p><strong>Explicação:</strong> O formulário é enviado ao servidor, que retorna um status à página. Dependendo do status, uma mensagem diferente é exibida. Observe na URL do navegador que a senha fica à mostra!</p>

<h2 id="Default-actions">Ação padrão</h2>

<p>Um arquivo <code>+page.server.js</code> pode exportar <em>ações</em>, permitindo o envio de dados ao servidor por meio de um formulário que utiliza o método <code>POST</code>.</p>

<p>Crie o arquivo <code ctc>src/routes/06/post/+page.svelte</code>:</p>

<pre><code>&lt;form method="POST"&gt;
  &lt;input name="email" type="email" placeholder="E-mail de usuário" /&gt;
  &lt;input name="senha" type="password" placeholder="Senha" /&gt;
  &lt;button&gt;Entrar&lt;/button&gt;
&lt;/form&gt;</code></pre>

<p>Explicação:</p>
<ul>
  <li>Ao submeter um formulário, ele é enviado ao servidor pela URL definida no atributo <code>action</code>.</li>
  <li>Como neste caso o atributo <code>action</code> não foi especificado, o formulário será enviado para a URL atual da página.</li>
</ul>

<p>Crie também o arquivo <code ctc>src/routes/06/post/+page.server.js</code>:</p>

<pre><code>export const actions = {
  default: async (event) =&gt; {
    console.log(event);
    console.log(await event.request.formData());
  }
};</code></pre>

<p>Explicação:</p>
<ul>
  <li>A função <code>default</code> será executada sempre que houver uma requisição <code>POST</code> para a rota <code>/06/post</code>, como no exemplo do formulário acima.</li>
  <li>O parâmetro <code>event</code> é um objeto <a target="_blank" href="https://svelte.dev/docs/kit/@sveltejs-kit#RequestEvent">RequestEvent</a>, que fornece informações detalhadas sobre a requisição.</li>
  <li>Como vimos no <a target="_blank" href="./03 Carregando dados do servidor.html#serverloadevent">capítulo anterior</a>, a função <code>load</code> recebe um objeto <a target="_blank" href="https://svelte.dev/docs/kit/@sveltejs-kit#ServerLoadEvent">ServerLoadEvent</a>, que herda os métodos de <code>RequestEvent</code>. Por isso, você já deve estar familiarizado com propriedades como <code>params</code>, <code>url</code> e <code>fetch</code>, disponíveis tanto em ações de formulário quanto na função <code>load</code>.</li>
  <li>Linha 3: Imprimimos o objeto <code>event</code> no terminal do servidor, para fins de teste.</li>
  <li>Linha 4: Para acessar os dados enviados pelo formulário, utilizamos o método assíncrono <code>formData()</code> do objeto <a target="_blank" href="https://developer.mozilla.org/en-US/docs/Web/API/Request"><code>request</code></a>, que é uma propriedade de <code>event</code>.</li>
</ul>

<div class="info">
  <p><strong>Observação:</strong> Ações sempre utilizam requisições <code>POST</code>, pois requisições <code>GET</code> não devem causar efeitos colaterais.</p>
</div>

<p>Também é possível enviar dados para outra rota informando o atributo <code>action</code> com a URL de destino.</p>

<p>Crie o arquivo <code ctc>src/routes/06/form/+page.svelte</code>:</p>

<pre><code>&lt;form method="POST" action="/06/post"&gt;
  &lt;input type="number" placeholder="Digite um número" /&gt;
  &lt;input name="umtexto" placeholder="Digite um texto" /&gt;
  &lt;input name="umadata" type="date" /&gt;
  &lt;button&gt;Entrar&lt;/button&gt;
&lt;/form&gt;</code></pre>

<p>Explicação: Ao incluir o atributo <code>action</code>, este formulário envia os dados para a rota <code>/06/post</code>, onde serão processados pela ação padrão dessa página.</p>

<div class="info">
  <p><strong>Observação:</strong> No servidor não é exibido o valor do campo numérico. Cada campo do formulário precisa ter o atributo <code>name</code> para que seus dados sejam incluídos na requisição enviada ao servidor.</p>
</div>

<p>Ótimo! Agora temos um meio eficiente de trocar dados entre páginas!</p>

<h2>Retornando dados</h2>
<p>Após processar a requisição (por exemplo, registrando o usuário), a ação pode retornar dados que ficam disponíveis por meio da propriedade <code>form</code> na página correspondente e também em <code>page.form</code> em todo o aplicativo, até a próxima atualização de página.</p>
<p>Modifique o arquivo <code ctc>src/routes/06/post/+page.server.js</code>:</p>
<pre><code class="js">export const actions = {
  default: async ({ request }) =&gt; {
    const data = await request.formData();
    const email = data.get('email');
    const senha = data.get('senha');
    if (!email || !senha) return { status: 400 };
    if (senha !== '1234') return { status: 401 };
    return { status: 200, email };
  }
};</code></pre>

<p>Explicação:</p>
<ul>
  <li>Linha 2: Utilizamos apenas a propriedade <code>request</code> do objeto <code>event</code>.</li>
  <li>Linhas 3–5: Extraímos o email e a senha enviados pelo formulário.</li>
  <li>Linhas 6-8: Assim como os dados retornados por <code>load</code> <a target="_blank" href="./03 Carregando dados do servidor.html#load-return">ficam disponíveis</a> na propriedade <code>data</code>, os dados retornados por uma ação de formulário ficam disponíveis na propriedade <code>form</code>.</li>
</ul>

<p>Agora, vamos exibir na página os dados retornados pelo servidor. Modifique o arquivo <code ctc>src/routes/06/post/+page.svelte</code>:</p>
<pre><code>&lt;script&gt;
  let { form } = $props();
&lt;/script&gt;

&lt;form method="POST"&gt;
  &lt;input name="email" type="email" placeholder="E-mail de usuário" /&gt;
  &lt;input name="senha" type="password" placeholder="Senha" /&gt;
  &lt;button&gt;Entrar&lt;/button&gt;
&lt;/form&gt;
{#if !form}
  &lt;p&gt;Preencha e submeta o formulário.&lt;/p&gt;
{:else if form.status == 400}
  &lt;p&gt;E-mail e senha são obrigatórios&lt;/p&gt;
{:else if form.status == 401}
  &lt;p&gt;Usuário ou senha inválidos&lt;/p&gt;
{:else if form.status == 200}
  &lt;p&gt;Login efetuado com sucesso!&lt;/p&gt;
  &lt;p&gt;Bem-vindo, {form.email}!&lt;/p&gt;
{/if}</code></pre>

<p>Explicação:</p>
<ul>
  <li>Linha 2: A propriedade <code>form</code> contém os dados retornados pela ação de formulário.</li>
  <li>Linha 10: Diferentemente de <code>load</code>, que sempre é executada quando declarada, ações de formulário só são executadas após uma requisição POST. Portanto, a propriedade form pode estar indefinida (ou nula?) caso o servidor não tenha recebido nenhuma requisição POST. Portanto, aqui verificamos se algo chegou a ser submetido do formulário.</li>
  <li>Linhas 12, 14 e 16 : Os possíveis status que o servidor pode retornar, cada qual ocasionando uma diferente mensagem a ser exibida.</li>
</ul>

<h2>Redirecionamentos</h2>
<p>Uma introdução sobre redireionamentos em sveltekit... Por exemplo, após o login de um usuário, podemos redirecioná-lo automaticamente para uma página de usuário.</p>

<p>Modifique o arquivo <code ctc>src/routes/06/post/+page.server.js</code>:</p>

<pre><code class="js">import { redirect } from '@sveltejs/kit';

export const actions = {
  default: async ({ request }) =&gt; {
    const data = await request.formData();
    const email = data.get('email');
    const senha = data.get('senha');
    if (!email || !senha) return { status: 400 };
    if (senha !== '1234') return { status: 401 };
    redirect(303, '/06/profile');
  }
};</code></pre>

<p>Explicação:</p>
<ul>
  <li><strong>Linha 1:</strong> Importamos a função <code>redirect</code>, necessária para realizar o redirecionamento.</li>
  <li id="profile"><strong>Linha 10:</strong> Se o login for bem-sucedido, redirecionamos o usuário para a rota <code>/06/profile</code> com o código HTTP 303. Crie essa rota com uma página com mensagem de boas vindas.</li>
</ul>

<div class="info">Toda resposta a uma requisição HTTP possui um código de status. Códigos na faixa dos 400 indicam erros do cliente, os da faixa dos 500 indicam erros do servidor, e os da faixa dos 300 representam redirecionamentos. Saiba mais na <a target="_blank" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Status">documentação do MDN</a>.</div>

<div class="info">
  <p>Observçao: A função redirect é um lançamento de exceção, ela encerra a função atual. Isso quer dizer que nenhum código é esperado ser executado após o redirct rodar.</p>
</div>

<div class="info">
  <p>Don’t use redirect() inside a try {...} block, as the redirect will immediately trigger the catch statement.</p>
</div>

<div class="info">
  <p>Redirecionamentos também podem ser usados em <a target="_blank" href="https://svelte.dev/docs/kit/load#Redirects"><code>load</code></a>.</p>
</div>

<h2>Validação de erros</h2>
<p>Se a requisição não puder ser processada devido a dados inválidos, é possível retornar mensagens de erro junto com os valores inseridos anteriormente. Isso permite que o usuário corrija os dados e tente novamente. A função <code>fail</code> retorna um código HTTP (geralmente 400 ou 422 em casos de erro de validação) junto com os dados. O código de status fica acessível em <code>page.status</code> e os dados em <code>form</code>.</p>
<p>Modifique o arquivo <code ctc>src/routes/06/post/+page.server.js</code>:</p>
<pre><code>import { fail, redirect } from '@sveltejs/kit';

export const actions = {
  default: async ({ request }) =&gt; {
    const data = await request.formData();
    const email = data.get('email');
    const senha = data.get('senha');

    if (!email || !senha) return fail(400, { error: 'Email e senha são obrigatórios.', email });

    if (!email.includes('@')) return fail(400, { error: 'Email inválido.', email });

    if (senha.length &lt; 4) return fail(400, { error: 'A senha deve ter pelo menos 4 caracteres.', email });

    if (email == "email@reservado") return fail(400, { error: 'Email já cadastrado.', email });

    redirect(303, '/06/profile');
  }
}</code></pre>

<p>Explicação:</p>
<ul>
  <li>Linhas 9–15: Validamos os dados. Se estiverem inválidos, usamos <code>fail</code> para retornar a mensagem de erro e manter os dados do formulário.</li>
  <li>Linha 11: A validação de email é simplificada. Em sistemas reais, utilize bibliotecas específicas e robustas para isso.</li>
  <li>Linha 15: Simulando que já existe um email. Impede que um email já registrado seja reutilizado.</li>
</ul>

<p>Modifique o arquivo <code ctc>src/routes/06/post/+page.svelte</code>:</p>
<pre><code>&lt;script&gt;
  let { form } = $props();
&lt;/script&gt;

&lt;form method="POST"&gt;
  &lt;input name="email" type="email" placeholder="E-mail de usuário" value={form?.email || ''} required /&gt;
  &lt;input name="senha" type="password" placeholder="Senha" /&gt;
  &lt;button&gt;Entrar&lt;/button&gt;
&lt;/form&gt;

{#if form?.error}
  &lt;p&gt;{form?.error}&lt;/p&gt;
{/if}</code></pre>

<p>Explicação:</p>
<ul>
  <li>Linha 6: O valor do campo email é mantido em caso de erro, para facilitar a correção por parte do usuário.</li>
  <li>Linha 7: Por segurança, a senha não é mantida após erro.</li>
  <li>Linha 12: Se houver erro, mostramos a mensagem apropriada.</li>
  <li>A validação no navegador (como <code>type="email"</code> e <code>required</code>) ajuda a evitar erros, mas a validação no servidor é indispensável, pois o código do cliente pode ser alterado pelo usuário. Para testar, inspecione o campo de e-mail, remova o atributo <code>type="email"</code> e tente enviar um endereço de e-mail inválido.</li>
</ul>

<h2>GET vs POST</h2>
<p>Como vimos, para invocar uma <em>ação de formulário</em>, é necessário usar <code>method="POST"</code>. No entanto, nem todo formulário precisa enviar dados ao servidor via POST — em formulários de busca, por exemplo, é comum utilizar <code>method="GET"</code> (ou simplesmente omitir o atributo <code>method</code>). Nesses casos, o SvelteKit trata o formulário como um link:</p>

<pre><code>&lt;form action="/search"&gt; &lt;label&gt; Search &lt;input name="q"&gt; &lt;/label&gt; &lt;/form&gt;</code></pre>

<p>Ao submeter esse formulário, o navegador navegará para <code>/search?q=...</code>, invocando a função <code>load</code>, mas sem invocar uma <code>action</code>.</p>



<h2 id="Named-actions">Ações nomeadas</h2>

<p>Em vez de usar apenas a ação <code>default</code>, uma página pode conter múltiplas ações nomeadas.</p>

<p>Crie o arquivo <code ctc>src/routes/06/named/+page.server.js</code>:</p>

<pre><code>import { fail } from '@sveltejs/kit';

export const actions = {
    multiplicar: async ({ request }) =&gt; {
        const data = await request.formData();
        const x = Number(data.get('x'));
        const y = Number(data.get('y'));

        if (isNaN(x) || isNaN(y)) return fail(400, { error: 'informe x e y.', x, y });

        return { result: x * y };
    },
    dividir: async ({ request }) =&gt; {
        const data = await request.formData();
        const x = Number(data.get('x'));
        const y = Number(data.get('y'));

        if (isNaN(x) || isNaN(y)) return fail(400, { error: 'informe x e y.', x, y });

        if (y == 0) return fail(400, { error: 'não é possível dividir por zero!', x, y });

        return { result: x / y };
    }
};</code></pre>

<p>Explicação:</p>
<ul>
  <li>Neste exemplo, temos duas ações distintas: <code>multiplicar</code> e <code>dividir</code>.</li>
  <li>Linhas 6, 7, 15 e 16: Os dados do formulário, mesmo que sejam numéricos, vêm na forma de string, portanto, usamos o comando <code>Number</code> para converter uma string em um número.</li>
  <li>Linhas 9 e 18: Aqui fazemos umas validações: Caso o usuário tenha burlado o sistema e digitado outra coisa que não número, então <code>Number</code> não conseguirá converter a string para número, e a função <code>isNaN</code>, de <em>is not a number</em>, vai retornar <code>true</code>.</li>
</ul>

<p>Para invocar uma ação nomeada, usamos um parâmetro de consulta no atributo <code>action</code>, começando com <code>?/</code> seguido do nome da ação.</p>
<p>Crie o arquivo <code ctc>src/routes/06/named/+page.svelte</code>:</p>

<pre><code>&lt;script&gt;
  let { form } = $props();
&lt;/script&gt;

&lt;form method="POST" action="?/multiplicar"&gt;
  &lt;label&gt;
    x: &lt;input name="x" type="number" step="0.01" value={form?.x ?? ''} required /&gt;
  &lt;/label&gt;
  &lt;br /&gt;
  &lt;label&gt;
    y: &lt;input name="y" type="number" step="0.01" value={form?.y ?? ''} required /&gt;
  &lt;/label&gt;
  &lt;br /&gt;
  &lt;button type="submit"&gt;Multiplicar&lt;/button&gt;
  &lt;button type="submit" formaction="?/dividir"&gt;Dividir&lt;/button&gt;
&lt;/form&gt;

{#if form &amp;&amp; form.error != undefined}
  &lt;p style="color: red"&gt;{form.error}&lt;/p&gt;
{/if}

{#if form &amp;&amp; form.result != undefined}
  &lt;p style="color: green"&gt;Resultado: {form.result}&lt;/p&gt;
{/if}</code></pre>

<p>Explicação:</p>
<ul>
  <li>Linha 5: O formulário principal será enviado para a ação nomeada <code>multiplicar</code>.</li>
  <li>Linha 15: O botão <code>Dividir</code> usa o atributo <code>formaction</code> para enviar o mesmo formulário à ação <code>dividir</code>, substituindo o <code>action</code> do formulário.</li>
  <li>Ambos os atributos <code>action</code> e <code>formaction</code> possuem somente um parâmetro de consulta como valor. Isso quer dizer que o formulário será enviado para o servidor na mesma rota da URL atual. Se você quisesse enviar o formulário para outra URL, os atributos ficariam algo como <code>action="/outra/rota?/multiplicar"</code>.</li>
</ul>

<div class="info">
  <p><strong>Atenção:</strong> não é recomendável combinar ação padrão com ações nomeadas na mesma página. Isso porque, se você fizer um <code>POST</code> para uma ação nomeada que não redireciona, o parâmetro de consulta (ex: <code>?/login</code>) permanece na URL. Assim, uma próxima submissão para a ação padrão continuará sendo tratada pela última ação nomeada, o que pode causar comportamentos inesperados.</p>
</div>

<h2>Exercícios</h2>
por favor, elabore exercícios sobre o capítulo aqui