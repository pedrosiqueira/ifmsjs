<!DOCTYPE html>

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
  <script src="https://unpkg.com/highlightjs-svelte/dist/svelte.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlightjs-line-numbers.js/2.9.0/highlightjs-line-numbers.min.js"></script>
  <script defer>hljs.configure({ languages: ["svelte"] }); hljs.highlightAll(); hljs.initLineNumbersOnLoad();</script>

  <!-- https://github.com/arronhunt/highlightjs-copy -->
  <link rel="stylesheet" href="https://unpkg.com/highlightjs-copy/dist/highlightjs-copy.min.css" />
  <script src="https://unpkg.com/highlightjs-copy/dist/highlightjs-copy.min.js"></script>
  <script defer>hljs.addPlugin(new CopyButtonPlugin());</script>

  <!-- https://github.com/TRSasasusu/highlightjs-highlight-lines.js -->
  <!-- <script src="https://cdn.jsdelivr.net/gh/TRSasasusu/highlightjs-highlight-lines.js@1.2.0/highlightjs-highlight-lines.min.js"></script>
  <script defer>hljs.highlightLinesAll([
      // [{ start: 2, end: 2, color: 'lightgreen' }, { start: 9, end: 9, color: 'lightblue' }, { start: 14, end: 14, color: 'lightblue' }]
    ]);
  </script> -->

  <!-- <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css" integrity="sha384-n8MVd4RsNIU0tAv4ct0nTaAbDJwPJzDEaqSD1odI+WdtXRGWt2kTvGFasHpSy3SV" crossorigin="anonymous">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js" integrity="sha384-XjKyOOlGwcjNTAIQHIpgOno0Hl1YQqzUOEleOLALmuqehneUG+vnGctmUb0ZY0l8" crossorigin="anonymous"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js" integrity="sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05" crossorigin="anonymous" onload="renderMathInElement(document.body,{delimiters:[{left: '$$', right: '$$', display: true},{left: '$', right: '$', display: false}]});"></script> -->

  <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/pedrosiqueira/custom-style/custom.min.css">
  <script src="https://cdn.jsdelivr.net/gh/pedrosiqueira/custom-style/custom.min.js"></script>
</head>

<h1 id="carregando-dados-no-sveltekit">Carregando Dados no SvelteKit</h1>
<p>Antes que um componente <code>+page.svelte</code> (e seus componentes <code>+layout.svelte</code> correspondentes) possa ser renderizado, frequentemente precisamos obter alguns dados. Isso é feito definindo funções <code>load</code>.</p>
<h2 id="dados-da-página">Dados da Página</h2>
<p>Um arquivo <code>+page.svelte</code> pode ter um arquivo irmão <code>+page.server.js</code> que exporta uma função <code>load</code>. O valor retornado por essa função estará disponível para a página através da propriedade <code>data</code>:</p>
<p>Crie o arquivo <code>src/routes/03/test/+page.server.js</code>:</p>
<pre><code class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">load</span>(<span class="hljs-params"></span>) {
	<span class="hljs-keyword">return</span> {
		<span class="hljs-attr">post</span>: {
			<span class="hljs-attr">title</span>: <span class="hljs-string">`Título de Exemplo`</span>,
			<span class="hljs-attr">content</span>: <span class="hljs-string">`Conteúdo de Exemplo`</span>
		},
    <span class="hljs-attr">author</span>: { <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Autor Exemplo&#x27;</span>, <span class="hljs-attr">email</span>: <span class="hljs-string">&#x27;autor@exemplo.com&#x27;</span> }
	};
}
</code></pre>
<p>Crie o arquivo <code>src/routes/03/test/+page.svelte</code>:</p>
<pre><code class="language-svelte">&lt;script&gt;
	let { data } = $props();
&lt;/script&gt;

&lt;h1&gt;{data.post.title}&lt;/h1&gt;
&lt;sub&gt;por {data.author.name}&lt;/sub&gt;
&lt;div&gt;{@html data.post.content}&lt;/div&gt;
</code></pre>
<p><strong>Explicação:</strong> A função <code>load</code> em <code>+page.server.js</code> retorna um objeto com os dados necessários para a página. Esses dados são acessados no componente Svelte através da propriedade <code>data</code>.</p>
<h2 id="dados-do-layout">Dados do Layout</h2>
<p>Teus arquivos <code>+layout.svelte</code> também podem carregar dados, via <code>+layout.server.js</code>.</p>
<p>Crie o arquivo <code>src/lib/server/database.js</code>:</p>
<pre><code class="language-javascript"><span class="hljs-keyword">const</span> posts = [
    { <span class="hljs-attr">slug</span>: <span class="hljs-string">&#x27;um&#x27;</span>, <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;Primeiro Post&#x27;</span>, <span class="hljs-attr">publish_date</span>: <span class="hljs-string">&#x27;2025-03-12&#x27;</span>, <span class="hljs-attr">content</span>: <span class="hljs-string">&#x27;Conteúdo do primeiro post&#x27;</span> },
    { <span class="hljs-attr">slug</span>: <span class="hljs-string">&#x27;outro&#x27;</span>, <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;Outro Post&#x27;</span>, <span class="hljs-attr">publish_date</span>: <span class="hljs-string">&#x27;2025-03-25&#x27;</span>, <span class="hljs-attr">content</span>: <span class="hljs-string">&#x27;Conteúdo do outro post&#x27;</span> },
    { <span class="hljs-attr">slug</span>: <span class="hljs-string">&#x27;algum&#x27;</span>, <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;Mais um Post&#x27;</span>, <span class="hljs-attr">publish_date</span>: <span class="hljs-string">&#x27;2024-11-22&#x27;</span>, <span class="hljs-attr">content</span>: <span class="hljs-string">&#x27;Conteúdo de mais um post&#x27;</span> },
    { <span class="hljs-attr">slug</span>: <span class="hljs-string">&#x27;ainda&#x27;</span>, <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;Ainda Outro Post&#x27;</span>, <span class="hljs-attr">publish_date</span>: <span class="hljs-string">&#x27;2024-11-02&#x27;</span>, <span class="hljs-attr">content</span>: <span class="hljs-string">&#x27;Conteúdo de ainda outro post&#x27;</span> }
];
</code></pre>
<p><strong>Explicação</strong>: Esse arquivo represetará nosso banco de dados.</p>
<p>Crie o arquivo <code>src/routes/03/posts/+layout.server.js</code>:</p>
<pre><code class="language-javascript"><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> db <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;$lib/server/database&#x27;</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">load</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">const</span> posts = db.<span class="hljs-title function_">getAll</span>();
  <span class="hljs-keyword">return</span> { posts };
}
</code></pre>
<p>Crie o arquivo <code>src/routes/03/posts/+layout.svelte</code>:</p>
<pre><code class="language-svelte">&lt;script&gt;
  import { page } from '$app/state';

  let { data, children } = $props();
&lt;/script&gt;

&lt;svelte:head&gt;
  &lt;title&gt;{page.data.post?.title || page.url.pathname}&lt;/title&gt;
&lt;/svelte:head&gt;

&lt;div class=&quot;row&quot;&gt;
  &lt;div class=&quot;col-4 bg-body-secondary&quot;&gt;
    &lt;aside&gt;
      &lt;h4&gt;Últimos Posts&lt;/h4&gt;
      &lt;ul&gt;
        {#each data.posts.slice(0, 2) as post}
          &lt;li&gt;
            &lt;a href=&quot;/03/posts/{post.slug}&quot;&gt;
              {post.title}
            &lt;/a&gt;
          &lt;/li&gt;
        {/each}
      &lt;/ul&gt;
    &lt;/aside&gt;
  &lt;/div&gt;
  &lt;div class=&quot;col&quot;&gt;
    &lt;main&gt;
      {@render children()}
    &lt;/main&gt;
  &lt;/div&gt;
&lt;/div&gt;
</code></pre>
<p><strong>Explicação:</strong> Dados retornados pela função <code>load</code> de um arquivo <code>+layout.server.js</code> ficam disponíveis para todos os seus componentes <code>.svelte</code> filhos, bem como para ele próprio. Aqui, o arquivo <code>+layout.server.js</code> carrega todos os posts e os disponibiliza para o layout e suas páginas filhas. No layout, exibimos os dois posts mais recentes em um menu lateral.</p>
<p>Vamos criar uma página filha. Crie o arquivo <code>src/routes/03/posts/+page.svelte</code>:</p>
<pre><code class="language-svelte">&lt;script&gt;
  let { data } = $props();
&lt;/script&gt;

&lt;h3&gt;Todos os Posts&lt;/h3&gt;
{#each data.posts as post}
  &lt;p&gt;&lt;a href=&quot;/03/posts/{post.slug}&quot;&gt;{post.title}&lt;/a&gt;&lt;/p&gt;
{/each}
</code></pre>
<p><strong>Explicação:</strong> A página principal lista todos os posts disponíveis, utilizando os dados fornecidos pelo layout.</p>
<blockquote>
  <p><strong>Nota:</strong> Se múltiplas funções <code>load</code> retornarem dados com a mesma propriedade, a última sobrescreve as anteriores. Por exemplo, se uma função <code>load</code> do layout retorna <code>{ a: 1, b: 2 }</code> e a da página retorna <code>{ b: 3, c: 4 }</code>, o resultado final será <code>{ a: 1, b: 3, c: 4 }</code>.</p>
</blockquote>
<h2 id="parâmetros-da-função-load">Parâmetros da Função Load</h2>
<p>A função <code>load</code> é invocada com um objeto <code>ServerLoadEvent</code> como parâmetro, que possui várias propriedades, como <code>params</code>, <code>url</code> e <code>fetch</code>.</p>
<h3 id="params">params</h3>
<p>Uma rota pode ser um caminho estático, como <code>src/routes/about</code>, ou um caminho dinâmico, como <code>src/routes/blog/[slug]</code> ou <code>src/routes/posts/[ano]/[mes]</code>. Neste caso, <code>[slug]</code>, <code>[ano]</code> e <code>[mes]</code> são chamados de parâmetros de rota, ou seja, variáveis que permitem diferentes valores levarem à mesma página.</p>
<p>Por exemplo:</p>
<ul>
  <li>A URL <code>/about</code> abrirá a página em <code>src/routes/about</code>.</li>
  <li>As URLs <code>/blog/post1</code> e <code>/blog/post2</code> abrirão a mesma página dinâmica em <code>src/routes/blog/[slug]</code>, sendo que o valor de <code>slug</code> será <code>post1</code> ou <code>post2</code>, respectivamente.</li>
  <li>Da mesma forma, <code>/posts/2025/03</code> e <code>/posts/2024/11</code> abrirão a página <code>src/routes/posts/[ano]/[mes]</code>, com <code>ano</code> sendo <code>2025</code> ou <code>2024</code>, e <code>mes</code> sendo <code>03</code> ou <code>11</code>.</li>
</ul>
<p>A propriedade <code>params</code> é um <strong>objeto</strong> onde cada propriedade corresponde ao nome do parâmetro definido entre colchetes na rota, e seu valor corresponde ao trecho da URL acessada.</p>
<p>Crie o arquivo <code>src/routes/03/posts/[ano]/[mes]/+page.server.js</code>:</p>
<pre><code class="language-javascript"><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> db <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;$lib/server/database&#x27;</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">load</span>(<span class="hljs-params">{ params }</span>) {
  <span class="hljs-keyword">const</span> posts = db.<span class="hljs-title function_">getByYearMonth</span>(params.<span class="hljs-property">ano</span>, params.<span class="hljs-property">mes</span>);
  <span class="hljs-keyword">return</span> { posts };
}
</code></pre>
<p>Crie o arquivo <code>src/routes/03/posts/[ano]/[mes]/+page.svelte</code>:</p>
<pre><code class="language-svelte">&lt;script&gt;
  let { data } = $props();
&lt;/script&gt;

&lt;h3&gt;Posts&lt;/h3&gt;

{#each data.posts as post}
  &lt;p&gt;&lt;a href=&quot;/03/posts/{post.slug}&quot;&gt;{post.title}&lt;/a&gt;&lt;/p&gt;
{/each}
</code></pre>
<p><strong>Explicação:</strong> Utilizamos os parâmetros de rota <code>ano</code> e <code>mes</code> para filtrar os posts por data.</p>
<p>Também podemos usar uma única página para exibir cada post separadamente.</p>
<p>Crie o arquivo <code>src/routes/03/posts/[slug]/+page.server.js</code>:</p>
<pre><code class="language-javascript"><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> db <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;$lib/server/database&#x27;</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">load</span>(<span class="hljs-params">{ params }</span>) {
  <span class="hljs-keyword">const</span> post = db.<span class="hljs-title function_">getBySlug</span>(params.<span class="hljs-property">slug</span>);
  <span class="hljs-keyword">return</span> { post };
}
</code></pre>
<p>Crie o arquivo <code>src/routes/03/posts/[slug]/+page.svelte</code>:</p>
<pre><code class="language-svelte">&lt;script&gt;
  let { data } = $props();
&lt;/script&gt;

&lt;h1&gt;{data.post.title}&lt;/h1&gt;
&lt;sub&gt;Em {data.post.publish_date}&lt;/sub&gt;
&lt;p&gt;{data.post.content}&lt;/p&gt;
</code></pre>
<p><strong>Explicação:</strong> Aqui, utilizamos o parâmetro de rota <code>slug</code> para buscar e exibir um post específico.</p>
<h3 id="url">url</h3>
<p>Além dos <strong>parâmetros de rota</strong>, também podemos passar informações pela <strong>URL</strong> usando o que chamamos de <strong>parâmetros de consulta</strong> — também conhecidos como <strong>query params</strong> ou <strong>search params</strong>.</p>
<p>Esses parâmetros aparecem após o símbolo <code>?</code> na URL. Por exemplo:</p>
<pre><code>https://meusite.com/produtos?categoria=livros&amp;ordem=preco
</code></pre>
<p>Nesse caso, a URL possui dois query params:</p>
<ul>
  <li><code>categoria</code> com valor <code>&quot;livros&quot;</code></li>
  <li><code>ordem</code> com valor <code>&quot;preco&quot;</code></li>
</ul>
<p>No SvelteKit, dentro da função <code>load</code>, você pode acessar esses dados através da propriedade <code>url</code>, que é um objeto do tipo <a href="https://developer.mozilla.org/en-US/docs/Web/API/URL">URL</a>. Esse objeto representa a URL da requisição e contém várias informações úteis, como:</p>
<ul>
  <li><code>origin</code>: origem da URL (ex: <code>https://meusite.com</code>)</li>
  <li><code>pathname</code>: caminho da URL (ex: <code>/produtos</code>)</li>
  <li><code>searchParams</code>: um objeto do tipo <a href="https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams">URLSearchParams</a>, que representa os parâmetros de consulta da URL e permite acessar facilmente os valores dos query params.</li>
</ul>
<p>Crie o arquivo <code>src/routes/03/posts/query/+page.server.js</code>:</p>
<pre><code class="language-javascript"><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> db <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;$lib/server/database&#x27;</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">load</span>(<span class="hljs-params">{ url }</span>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(url);
  <span class="hljs-keyword">const</span> title = url.<span class="hljs-property">searchParams</span>.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;title&#x27;</span>) || <span class="hljs-literal">null</span>;
  <span class="hljs-keyword">const</span> content = url.<span class="hljs-property">searchParams</span>.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;content&#x27;</span>) || <span class="hljs-literal">null</span>;

  <span class="hljs-keyword">if</span> (!title &amp;&amp; !content) <span class="hljs-keyword">return</span> { <span class="hljs-attr">posts</span>: db.<span class="hljs-title function_">getAll</span>() };

  <span class="hljs-keyword">return</span> { <span class="hljs-attr">posts</span>: db.<span class="hljs-title function_">getByQuery</span>(title, content) };
}
</code></pre>
<blockquote>
  <p>💡 <strong>Dica:</strong> Neste exemplo, usamos <code>console.log()</code> para exibir o conteúdo da URL e dos parâmetros no terminal ou no console do navegador. Essa é uma ferramenta muito útil para <strong>debugar</strong> (ou seja, investigar e entender o que está acontecendo no seu código).</p>
  <p>Sempre que estiver em dúvida sobre o que uma variável contém, experimente usar <code>console.log(minhaVariavel)</code> para visualizar seu valor. Isso pode ajudar bastante na hora de identificar problemas e entender melhor o fluxo do programa.</p>
</blockquote>
<p>Crie o arquivo <code>src/routes/03/posts/query/+page.svelte</code>:</p>
<pre><code class="language-svelte">&lt;script&gt;
  let { data } = $props();
&lt;/script&gt;

&lt;form&gt;
  &lt;input type=&quot;text&quot; name=&quot;title&quot; placeholder=&quot;Search by title...&quot; /&gt;
  &lt;input type=&quot;text&quot; name=&quot;content&quot; placeholder=&quot;Search by content...&quot; /&gt;
  &lt;button type=&quot;submit&quot;&gt;Search&lt;/button&gt;
&lt;/form&gt;

&lt;h1&gt;Busca de posts&lt;/h1&gt;

&lt;ul&gt;
  {#each data.posts as post}
    &lt;li&gt;&lt;a href=&quot;/03/posts/{post.slug}&quot;&gt;{post.title}&lt;/a&gt;&lt;/li&gt;
  {:else}
    &lt;li&gt;Nenhum resultado encontrado.&lt;/li&gt;
  {/each}
&lt;/ul&gt;
</code></pre>
<p><strong>Explicação:</strong> Neste exemplo, a função <code>load</code> acessa os parâmetros da URL usando <code>url.searchParams.get('termo')</code>, permitindo buscar posts por título. Isso simula uma funcionalidade de busca baseada em query strings.</p>
<h3 id="fetch">fetch</h3>
<p>Para buscar dados de uma API externa ou do seu próprio servidor, você pode usar a função <code>fetch</code> disponibilizada pelo SvelteKit. Ela se comporta de forma idêntica à API nativa <code>fetch</code>, mas com algumas vantagens:</p>
<ul>
  <li>Pode ser usada para fazer requisições autenticadas no servidor, herdando cookies e cabeçalhos de autorização da requisição da página.</li>
  <li>Requisições internas (como para rotas <code>+server.js</code>) são redirecionadas diretamente para o manipulador de requisições no servidor, sem o overhead de uma chamada HTTP.</li>
  <li>Em alguns casos, é mais eficiente, pois <strong>evita uma requisição adicional</strong> (<a href="https://svelte.dev/docs/kit/load#Making-fetch-requests">veja na documentação</a>).</li>
</ul>
<p>Crie o arquivo <code>src/routes/03/external/users/+page.server.js</code>:</p>
<pre><code class="language-js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">load</span>(<span class="hljs-params">{ fetch }</span>) {
  <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;https://jsonplaceholder.typicode.com/users&#x27;</span>);
  <span class="hljs-keyword">const</span> users = <span class="hljs-keyword">await</span> res.<span class="hljs-title function_">json</span>();
  <span class="hljs-keyword">return</span> { users };
}
</code></pre>
<p><strong>Explicação:</strong> Esse código faz uma requisição para a API externa e retorna os dados dos usuários. Como está em <code>+page.server.js</code>, a requisição sempre será feita no servidor, protegendo eventuais dados sensíveis.</p>
<p>Crie o arquivo <code>src/routes/03/external/users/+page.svelte</code>:</p>
<pre><code class="language-svelte">&lt;script&gt;
  let { data } = $props();
&lt;/script&gt;

&lt;h3&gt;Usuários&lt;/h3&gt;
&lt;ul&gt;
  {#each data.users as user}
    &lt;li&gt;&lt;a href=&quot;/03/external/users/{user.id}&quot;&gt;{user.name}&lt;/a&gt;&lt;/li&gt;
  {/each}
&lt;/ul&gt;
</code></pre>
<p><strong>Explicação:</strong> Aqui, iteramos sobre os usuários carregados e mostramos uma lista com links para cada um.</p>
<p>Agora vamos carregar as informações de um usuários, bem como suas postagens. Crie o arquivo <code>src/routes/03/external/users/[id]/+page.server.js</code>:</p>
<pre><code class="language-js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">load</span>(<span class="hljs-params">{ params, fetch }</span>) {
  <span class="hljs-keyword">const</span> resUser = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">`https://jsonplaceholder.typicode.com/users/<span class="hljs-subst">${params.id}</span>`</span>);
  <span class="hljs-keyword">const</span> user = <span class="hljs-keyword">await</span> resUser.<span class="hljs-title function_">json</span>();

  <span class="hljs-keyword">const</span> resPosts = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">`https://jsonplaceholder.typicode.com/users/<span class="hljs-subst">${params.id}</span>/posts`</span>);
  <span class="hljs-keyword">const</span> posts = <span class="hljs-keyword">await</span> resPosts.<span class="hljs-title function_">json</span>();

  <span class="hljs-keyword">return</span> { user, posts };
}
</code></pre>
<p><strong>Explicação:</strong> Usamos <code>params.id</code> para buscar os dados de um usuário específico e também suas postagens. Retornamos tudo no objeto <code>data</code>.</p>
<p>Crie o arquivo <code>src/routes/03/external/users/[id]/+page.svelte</code>:</p>
<pre><code class="language-svelte">&lt;script&gt;
  let { data } = $props();
&lt;/script&gt;

&lt;h3&gt;User&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Nome:&lt;/strong&gt; {data.user.name}&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Email:&lt;/strong&gt; {data.user.email}&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Telefone:&lt;/strong&gt; {data.user.phone}&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Website:&lt;/strong&gt; {data.user.website}&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Companhia:&lt;/strong&gt; {data.user.company.name}&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Endereço:&lt;/strong&gt; {data.user.address.street}, {data.user.address.suite}, {data.user.address.city}, {data.user.address.zipcode}&lt;/p&gt;

&lt;h3&gt;Postagens do usuário&lt;/h3&gt;
&lt;ul&gt;
  {#each data.posts as post}
    &lt;li&gt;&lt;a href=&quot;/03/external/posts/{post.id}&quot;&gt;{post.title}&lt;/a&gt;&lt;/li&gt;
  {:else}
    &lt;p&gt;Nenhuma postagem encontrada.&lt;/p&gt;
  {/each}
&lt;/ul&gt;
&lt;p&gt;
  &lt;a href=&quot;/03/external/users&quot;&gt;Back to users&lt;/a&gt;
&lt;/p&gt;
</code></pre>
<p><strong>Explicação:</strong> Exibimos os detalhes do usuário e uma lista de suas postagens. Também incluímos um link de volta à lista de usuários.</p>
<h2 id="pagedata">page.data</h2>
<p>O componente <code>+page.svelte</code>, assim como cada <code>+layout.svelte</code> acima dele na hierarquia, tem acesso aos seus próprios dados e também aos dados de todos os seus layouts &quot;pais&quot;.</p>
<p>No entanto, em algumas situações precisamos do contrário — um layout &quot;pai&quot; pode precisar acessar dados carregados por uma página ou por um layout &quot;filho&quot;.<br>
  Um exemplo comum é o layout raiz (<code>+layout.svelte</code>) querer acessar uma propriedade <code>title</code> retornada pela função <code>load</code> de um <code>+page.server.js</code>.</p>
<p>Para isso, utilizamos <code>page.data</code>.</p>
<p><strong>Modifique</strong> o arquivo <code>src/routes/03/posts/+layout.svelte</code>:</p>
<pre><code class="language-svelte">&lt;script&gt;
  import { page } from '$app/state';
  let { data, children } = $props();

  console.log(page);
&lt;/script&gt;

&lt;svelte:head&gt;
  &lt;title&gt;{page.data.post?.title || page.url.pathname}&lt;/title&gt;
&lt;/svelte:head&gt;

&lt;div class=&quot;row&quot;&gt;
  &lt;div class=&quot;col-4 bg-body-secondary&quot;&gt;
    &lt;aside&gt;
      &lt;h4&gt;Latest posts&lt;/h4&gt;
      &lt;ul&gt;
        {#each data.posts.slice(0, 2) as post}
          &lt;li&gt;
            &lt;a href=&quot;/03/posts/{post.slug}&quot;&gt;
              {post.title}
            &lt;/a&gt;
          &lt;/li&gt;
        {/each}
      &lt;/ul&gt;
    &lt;/aside&gt;
  &lt;/div&gt;
  &lt;div class=&quot;col&quot;&gt;
    &lt;main&gt;
      {@render children()}
    &lt;/main&gt;
  &lt;/div&gt;
&lt;/div&gt;
</code></pre>
<p><strong>Explicação:</strong> Aqui, o layout acessa <code>page.data.post?.title</code> para definir o título da aba dinamicamente com base na página carregada.</p>
<h2 id="cliente-vs-servidor">Cliente vs Servidor</h2>
<p>Além das funções <code>load</code> nos arquivos <code>+layout.server.js</code> e <code>+page.server.js</code>, que sempre são executadas no servidor, também existem as funções <code>load</code> nos arquivos <code>+layout.js</code> e <code>+page.js</code>, conhecidas como funções <code>load</code> universais. Essas funções podem ser executadas tanto no servidor quanto no navegador (a menos que sejam combinadas com <code>export const ssr = false</code>, caso em que elas serão executadas (somente no navegador)[<a href="https://svelte.dev/docs/kit/page-options#ssr">https://svelte.dev/docs/kit/page-options#ssr</a>]).</p>
<p>Por padrão, as funções <code>load</code> universais são executadas no servidor durante o SSR (Server-Side Rendering) quando o usuário visita a página pela primeira vez. Elas serão executadas novamente durante o processo de (hidratação)[<a href="https://svelte.dev/docs/kit/glossary#Hydration">https://svelte.dev/docs/kit/glossary#Hydration</a>], reutilizando quaisquer respostas de (requisições fetch)[<a href="https://svelte.dev/docs/kit/load#Making-fetch-requests">https://svelte.dev/docs/kit/load#Making-fetch-requests</a>] feitas anteriormente. Todas as invocações subsequentes dessas funções <code>load</code> universais ocorrerão no navegador. Você pode personalizar esse comportamento por meio das (opções da página)[<a href="https://svelte.dev/docs/kit/page-options">https://svelte.dev/docs/kit/page-options</a>]. Por exemplo, se desativar a opção de página (server-side rendering)[<a href="https://svelte.dev/docs/kit/page-options#ssr">https://svelte.dev/docs/kit/page-options#ssr</a>], você estará criando uma SPA (Single Page Application), e todas as funções <code>load</code> universais serão executadas no cliente.</p>
<p>Se uma rota contiver tanto funções <code>load</code> universais quanto funções <code>load</code> específicas para o servidor, a função <code>load</code> do servidor será executada primeiro.</p>
<p>A função <code>load</code> é invocada em tempo de execução, a menos que você (pré-renderize)[<a href="https://svelte.dev/docs/kit/page-options#prerender">https://svelte.dev/docs/kit/page-options#prerender</a>] a página — nesse caso, ela será invocada em tempo de compilação.</p>
<h3 id="quando-usar-cada-tipo">Quando usar cada tipo</h3>
<ul>
  <li>
    <p>Se a sua função <code>load</code> deve ser executada sempre no servidor, por exemplo, quando utiliza variáveis de ambiente privadas ou acessa um banco de dados ou sistema de arquivos, ela deve ser colocada em um <code>+page.server.js</code>.</p>
  </li>
  <li>
    <p>Como o SvelteKit pode acessar os dados diretamente da API sem passar pelo seu servidor, se você precisar buscar dados de uma API externa e não precisar de credenciais privadas, use o <code>+page.js</code>.</p>
  </li>
</ul>
<h2 id="conclusão">Conclusão</h2>
<p>O SvelteKit oferece uma série de recursos poderosos para carregar dados de maneira eficiente, seja do servidor, de APIs externas ou de fontes internas. Ao entender as diferenças entre as funções <code>load</code> nos arquivos <code>+page.server.js</code>, <code>+layout.server.js</code>, <code>+page.js</code> e <code>+layout.js</code>, você pode otimizar o desempenho de teu aplicativo, aproveitando o que há de melhor em renderização no servidor e no cliente. Para explorar mais sobre esses recursos e como aplicá-los, consulte a <a href="https://svelte.dev/docs/kit/load">documentação oficial</a>.</p>
<h2 id="exercícios">Exercícios</h2>
<ol class="excs">
  <li>Tornar as páginas de teu aplicativo SvelteKit completamente navegáveis, permitindo a navegação entre todas as rotas criadas.</li>
</ol>
<p><strong>Passos:</strong></p>
<ol>
  <li>
    <p>Crie um menu de navegação simples com links para todas as páginas criadas.</p>
  </li>
  <li>
    <p>Assegure que cada página tenha um link de navegação que a leve de volta à página inicial ou para outra página do aplicativo.</p>
  </li>
  <li>
    <p>Teste a navegação para garantir que todas as páginas estão acessíveis e funcionando corretamente.</p>
  </li>
  <li>
    <p>Implementar operações utilizadas do banco de dados <code>database.js</code>:</p>
    <ol>
      <li>getAll()</li>
      <li>getByYearMonth(params.ano, params.mes)</li>
      <li>getBySlug(params.slug)</li>
      <li>getByQuery(title, content)</li>
    </ol>
  </li>
  <li>
    <p>Utilizando a API REST <a href="https://pokeapi.co/">https://pokeapi.co/</a>, implemente uma página que liste os pokémons, com um link que redireciona para a página de detalhes de cada pokémon.</p>
  </li>
  <p><strong>Possível solução:</strong></p>
  <p>Crie o arquivo <code ctc>src/routes/03/pokemon/+page.svelte</code></p>
  <pre><code>&lt;script&gt;
  let { data } = $props();
&lt;/script&gt;

&lt;div class="row"&gt;
  {#each data.pokemons as p}
    &lt;div class="col-md-3 col-sm-6 mb-3"&gt;
      &lt;div class="card"&gt;
        &lt;img src={p.image} alt={p.name} class="card-img-top" /&gt;
        &lt;div class="card-body"&gt;
          &lt;a href="/03/pokemon/{p.name}" class="stretched-link text-decoration-none"&gt;
            &lt;h5 class="card-title text-capitalize"&gt;{p.name}&lt;/h5&gt;
          &lt;/a&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  {/each}
&lt;/div&gt;</code></pre>
  <p>Explicação:</p>
  <p>Este código cria uma lista de pokémons com suas imagens. Cada card é colocado em uma coluna que ocupa largura 3/12 em telas médias pra cima, e largura 6/12 em telas pequenas pra cima, e ocupa 100% da largura em telas menores. O link que direciona para uma página com mais informações sobre o Pokémon.</p>
  <p>A classe <code>card-img-top</code> é usada para a imagem, e <code>card-body</code> envolve o conteúdo textual. <code>stretched-link</code> permite que a área inteira do card seja clicável.</p>

  <p>Agora vamos ver de onde os dados são carregados.</p>
  <p>Crie o arquivo <code ctc>src/routes/03/pokemon/+page.js</code></p>
  <pre><code class="js">export async function load() {
  const limit = 12;
  const offset = 0;

  const res = await fetch(`https://pokeapi.co/api/v2/pokemon?offset=${offset}&limit=${limit}`);
  const data = await res.json();

  for (const pokemon of data.results) {
    const id = pokemon.url.split("/").at(-2);
    pokemon.image = `https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/${id}.png`;
  }

  return { pokemons: data.results };
}</code></pre>
  <p>Explicação:</p>
  <p>O código faz uma requisição à PokeAPI para listar os pokémons com limite de 12 por página. Ele extrai o ID da URL e gera a URL da imagem correspondente.</p>


  <li>
    <p>Implemente paginação para listar os Pokémons.</p>
    <p><strong>Passos</strong>:</p>
    <ol>
      <li>Exiba apenas um número limitado de itens por página (por exemplo, 20 pokémons por página).</li>
      <li>Implemente botões de navegação para mudar de página, como &quot;Próximo&quot; e &quot;Anterior&quot;.</li>
      <li>Ao clicar em um botão de navegação, a página será atualizada com os novos itens da próxima ou da página anterior.</li>
      <li>Teste a navegação para garantir que a paginação funcione corretamente, carregando os pokémons conforme esperado.</li>
    </ol>
  </li>
  <li>
    <p>Quando o usuário clicar em um pokémon, crie uma página dedicada para exibir os detalhes desse pokémon.</p>
  </li>
  <li>
    <p>Implemente uma funcionalidade de busca para filtrar os pokémons com base em parâmetros de consulta (query params), como o tipo do pokémon.</p>
  </li>
</ol>