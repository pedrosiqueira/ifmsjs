<!DOCTYPE html>
<html lang="pt">

<head>
    <script>
        document.addEventListener("DOMContentLoaded", function () {

        }, false);
    </script>

    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/default.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlightjs-line-numbers.js/2.8.0/highlightjs-line-numbers.min.js"></script>
    <script defer>hljs.configure({ cssSelector: "code", languages: ["javascript"] }); hljs.highlightAll(); hljs.initLineNumbersOnLoad();</script>

    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css" integrity="sha384-vKruj+a13U8yHIkAyGgK1J3ArTLzrFGBbBc0tDp4ad/EyewESeXE/Iv67Aj8gKZ0" crossorigin="anonymous">
    <!-- The loading of KaTeX is deferred to speed up page rendering -->
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.js" integrity="sha384-PwRUT/YqbnEjkZO0zZxNqcxACrXe+j766U2amXcgMg5457rve2Y7I6ZJSm2A0mS4" crossorigin="anonymous"></script>

    <style>
        img {
            max-width: 100%;
        }

        .center {
            text-align: center;
        }

        table.custom,
        table.custom td,
        table.custom th {
            border: 1px solid black;
            border-collapse: collapse;
            margin-left: auto;
            margin-right: auto;
            text-align: center;
        }

        ol.excs {
            padding-inline-start: 0em;
            counter-reset: excs;
            list-style: none;
        }

        ol.excs>li::before {
            counter-increment: excs;
            content: counters(excs, ".") ". ";
        }

        ol.excs>li {
            /* Change this to adjust the line color and thickness */
            border-left: 2px solid #000;
            /* Optional: Add padding to create some space between the bar and content */
            padding-left: 10px;

            margin-block-start: 1em;
            margin-block-end: 1em;
        }

        ol.section {
            counter-reset: section;
            list-style-type: none;
        }

        ol.section li::before {
            counter-increment: section;
            content: counters(section, ".") ". ";
        }

        td.hljs-ln-numbers {
            color: #ccc;
            border-right: 1px solid #999;
            padding-right: 5px;
        }

        td.hljs-ln-code {
            padding-left: 10px;
        }
    </style>
</head>

<div id="preparando-o-ambiente-de-desenvolvimento">
    <h1>Preparando o ambiente de desenvolvimento</h1>
    <h2>Introdução</h2>
    <p>Os computadores não compreendem linguagens de programação diretamente; elas precisam ser convertidas para a <b>linguagem de máquina</b>, composta apenas por 0s e 1s (binário), que é a única linguagem que o computador entende. Para converter um código em linguagem de máquina, dependendo da linguagem de programação, é usado um processo que pode ser de <b>compilação</b> ou de <b>interpretação</b>.</p>
    <p>Linguagens de programação compiladas são aquelas em que o código-fonte é traduzido para código de máquina antes da execução do programa (imagem: arquivo de texto para arquivo binário). Esse processo é realizado por um compilador, um programa que analisa o código-fonte e o converte em instruções diretamente compreensíveis pela arquitetura da máquina alvo. Essa tradução antecipada permite que o programa seja executado com eficiência e rapidez, uma vez que as instruções já foram processadas e otimizadas antes da execução.</p>
    <p>Por outro lado, linguagens de programação interpretadas não são traduzidas para código de máquina antes da execução. Em vez disso, um interpretador analisa o código-fonte linha por linha durante a execução do programa. Isso significa que cada vez que o programa é executado, o interpretador deve analisar e traduzir novamente o código-fonte para instruções compreensíveis pela máquina. Embora esse processo possa ser mais lento em comparação com a compilação, as linguagens interpretadas oferecem maior portabilidade, pois o mesmo código-fonte pode ser executado em diferentes sistemas operacionais e arquiteturas, desde que haja um interpretador disponível para a linguagem em questão.</p>
    <p>Algumas linguagens, como Python e JavaScript (JS), usam uma abordagem intermediária entre compilação e interpretação. Nesses casos, o código-fonte é primeiro compilado para um formato de baixo nível chamado <b>bytecode</b> (imagem: arquivo de texto para arquivo de bytecode). O bytecode é uma representação binária das instruções que a <b>máquina virtual</b> específica da linguagem pode entender. Em seguida, a máquina virtual, é responsável por executar esse bytecode. Dessa forma, o código-fonte é traduzido apenas uma vez para bytecode e depois pode ser executado por diferentes máquinas virtuais em diferentes plataformas, proporcionando a portabilidade das linguagens interpretadas sem a necessidade de interpretar o código-fonte linha por linha repetidamente.</p>
    <p>Bytecodes permitem aplicar a técnica de <b>compilação Just-In-Time</b> (JIT). A compilação JIT ocorre em tempo de execução, isto é, durante a execução do bytecode, em vez de ser realizada antecipadamente, como na compilação tradicional. Durante a execução, um compilador JIT analisa o bytecode e traduz partes do código em código de máquina otimizado para a arquitetura específica do computador em que está sendo executado. Esse código de máquina é armazenado em cache para reutilização em futuras execuções do mesmo trecho de código, evitando a necessidade de recompilação repetitiva.</p>
    <p>A execução de partes específicas do código otimizado em código de máquina pode melhorar significativamente o desempenho em comparação com a interpretação linha por linha ou a execução de bytecode não compilado para código de máquina. A compilação JIT também permite que a linguagem de programação forneça uma combinação de portabilidade e eficiência, pois o mesmo código-fonte pode ser executado em diferentes plataformas, mas o compilador JIT pode gerar código de máquina otimizado para cada plataforma específica.</p>
    <p></p>

    <h2>Instalação</h2>
    <h3>Via navegador web</h3>
    <p>Como as páginas web utilizam HTML+CSS+JavaScript, um bom navegador web moderno já vem com o interpretador de JavaScript instalado. Para executar códigos JavaScript, acesse as Ferramentas do Desenvolvedor do teu navegador web de preferência (na maioria dos navegadores, o atalho é a tecla F12), e abra a aba "Console". Esta aba é um terminal interativo, onde os comandos podem ser inseridos e executados um de cada vez.</p>
    <h3>Como programa</h3>
    <p>Um Ambiente de Execução (Runtime Enviroment) é um kit com tudo que precisamos, como a máquina virtual e compilador JIT, para executar código de uma determinada linguagem de programação. Para o JavaScript, instalaremos o ambiente de execução Node.js (node). Assim, conseguimos desenvolver e executar programas JavaScript sem a necessidade de um navegador web. O Node.js vem com o Node Package manager (npm), que é uma ferramenta que permite instalar bibliotecas de terceiros (códigos de outras pessoas) usando a linha de comando.</p>
    <p>Vamos instalar o Node Version Manager (nvm) e usá-lo para instalar o node e o npm. Recomendamos o uso de um gerenciador de versões, pois as versões mudam muito rapidamente. Você provavelmente precisará alternar entre várias versões do node com base nas necessidades dos diferentes projetos em que está trabalhando. O Node Version Manager (nvm) é um gerenciador de versões do node muito popular.</p>
    <p>É sempre recomendável remover qualquer instalação existente do node ou npm antes de instalar um gerenciador de versões, pois diferentes tipos de instalação podem levar a conflitos.</p>

    <h4>Linux</h4>
    <ol>
        <li>Instale o nvm: <code>wget -O - https://raw.githubusercontent.com/nvm-sh/nvm/master/install.sh | bash</code>.</li>
        <li>Verifique se o nvm foi instalado (talvez seja necessário reiniciar o terminal): <code>nvm --version</code>. Deve aparecer a versão instalada do nvm, que, nesta data, é 0.39.7.</li>
        <li>Liste as versões disponíveis do node: <code>nvm ls</code>.</li>
        <li>Confirme que nenhuma versão do node está instalada: <code>nvm use node</code>. Deve aparecer algo como "not yet installed".</li>
        <li>Instale a versão LTS estável atual do node (recomendada para aplicativos em produção): <code>nvm install --lts</code>.</li>
        <li>Verifique se o node foi instalado: <code>node --version</code>. Verifique também se o npm foi instalado junto com o node: <code>npm --version</code>.</li>
        <li>Para alterar a versão do node, por exemplo, para a versão 18.2.0: <code>nvm use v18.2.0</code>. Lembrando que a versão deve estar instalada antes de mudar para ela. Para alterar para a última versão LTS: <code>nvm use --lts</code>.</li>
    </ol>

    <h4>Windows</h4>
    <p>Baixe e instale o node pelo <a href="https://nodejs.org/">site oficial</a>.</p>
    <p>Como alternativa, você pode instalar o Windows Subsystem for Linux (WSL): <a href="https://learn.microsoft.com/en-us/windows/wsl/install">https://learn.microsoft.com/en-us/windows/wsl/install</a>. Depois, siga o tutorial de instalação do NodeJS para Windows: <a href="https://learn.microsoft.com/en-us/windows/dev-environment/javascript/nodejs-on-wsl">https://learn.microsoft.com/en-us/windows/dev-environment/javascript/nodejs-on-wsl</a>.</p>

    <h2>Ambiente de desenvolvimento integrado</h2>
    <p>Para facilitar o desenvolvimento de programas em JavaScript, usaremos o Visual Studio Code (vscode). Trata-se de um Ambiente de Desenvolvimento Integrado (IDE) que integra recursos para escrever, depurar, compilar e gerenciar dependências de código em um único lugar. Você pode baixar o VSCode <a href="https://code.visualstudio.com/download">aqui</a>.</p>
    <p>Já com o JavaScript instalado, abra o vscode e acesse a aba de extensões (atalho <kbd>Ctrl + Shift + X</kbd>). Em seguida, instale as seguintes extensões:</p>
    <ul>
        <li><a href="https://marketplace.visualstudio.com/items?itemName=VisualStudioExptTeam.vscodeintellicode">VisualStudioExptTeam.vscodeintellicode</a></li>
        <li><a href="https://marketplace.visualstudio.com/items?itemName=VisualStudioExptTeam.intellicode-api-usage-examples">VisualStudioExptTeam.intellicode-api-usage-examples</a></li>
        <li><a href="https://marketplace.visualstudio.com/items?itemName=dbaeumer.vscode-eslint">dbaeumer.vscode-eslint</a></li>
        <li><a href="https://marketplace.visualstudio.com/items?itemName=xabikos.JavaScriptSnippets">xabikos.JavaScriptSnippets</a></li>
        <li><a href="https://marketplace.visualstudio.com/items?itemName=christian-kohler.npm-intellisense">christian-kohler.npm-intellisense</a></li>
        <li>Caso esteja usando WSL ou Docker, Pacote de extensões <a href="https://marketplace.visualstudio.com/items?itemName=ms-vscode-remote.vscode-remote-extensionpack">Remote Development</a></li>
        <!-- <li><a href="https://marketplace.visualstudio.com/items?itemName=christian-kohler.path-intellisense">christian-kohler.path-intellisense</a></li> -->
        <!-- <li><a href="https://marketplace.visualstudio.com/items?itemName=ms-vscode.js-debug">JavaScript Debugger</a> (a versão "estável" já vem instalada junto com o vs code).</li> -->
    </ul>
    <h2>Criando nosso projeto</h2>
    <p>É muito importante mantermos organizado nosso ambiente de trabalho. Como programadores, separamos nossos códigos em projetos, que são pastas que agrupam nossos arquivos de código.</p>
    <p>Crie uma pasta para armazenar todos os nossos códigos relacionados à nossa matéria. Eu chamarei esta pasta de <code>algoritmos</code>.</p>
    <p>Pelo vscode, acesse a aba de explorador de pastas (atalho <kbd>Ctrl + Shift + X</kbd>) e abra a pasta recém criada (atalho <kbd>Ctrl + K Ctrl + O</kbd>).</p>
    <p>Organizaremos a pasta da nossa matéria por capítulos. Criaremos uma pasta para cada capítulo, onde colocaremos os códigos desenvolvidos naquele capítulo.</p>
    <p>Como estamos no segundo capítulo, crie a pasta <code>cap02</code> dentro da pasta da nossa matéria. Você pode fazer isso no vscode clicando com o botão direito no espaço vazio da aba de explorador e selecionando "New folder...".</p>
    <p>Agora, crie o arquivo <code>hello-world.js</code> dentro da pasta <code>cap02</code>. Você pode fazer isso no vscode clicando com o botão direito em cima da pasta e selecionando "New file...". Observe que todos os arquivos de código-fonte em JavaScript devem terminar com a extensão <code>.js</code>.</p>
    <p>Escreva o código <code>console.log('hello, world!')</code> dentro do arquivo recém-criado. Para executar esse arquivo, com o terminal aberto na pasta raiz do projeto, execute <code>node cap02/hello-world.js</code>. Parabéns, esse é seu primeiro programa em JavaScript!</p>
    <p>Você também pode configurar o vscode para executar qualquer arquivo apenas teclando a tecla de atalho <kbd>F5</kbd>. Para tanto, acesse o menu "Run => Add Configuration => Node.js". No arquivo recém-criado <code>.vscode/launch.json</code>, adicione a seguinte linha, logo acima da linha que contém <code>"type":"node",</code>:</p>
    <pre><code>            "console": "integratedTerminal",</code></pre>
    <p>Essa linha configura o JavaScript para executar os arquivos pelo terminal, pois assim poderemos interagir com nossos programas.</p>

    <h2>Debugging</h2>
    <p>Errar faz parte do processo de aprendizagem, especialmente na programação. No entanto, às vezes é difícil encontrar a fonte de um erro no código. É aí que entra a arte de <b>debugging</b>. Debugging, ou depuração de código, é o processo de identificar, isolar e corrigir erros em um programa de computador. Quando um programa apresenta comportamentos inesperados, é necessário depurar o código para encontrar e resolver o problema. Isso envolve pausar a execução do programa, observar variáveis e valores em diferentes pontos do código e identificar onde ocorrem os erros. O debugging também é útil para entender o funcionamento do programa, permitindo que você o execute passo a passo, no seu próprio ritmo.</p>
    <p>Crie o arquivo <code>factorials.js</code> dentro da pasta <code>cap02</code>, e adicione o seguinte código no arquivo:</p>
    <pre><code>function calculateSumOfFactorials(argument1, argument2) {
    let factorial1 = calculateFactorial(argument1);
    let factorial2 = calculateFactorial(argument2);
    let result = calculateSum(factorial1, factorial2);
    return result;
}

function calculateFactorial(argument) {
    let factorialResult = 1;
    for (let i = 1; i &lt;= argument; i++) {
        factorialResult *= i;
    }
    return factorialResult;
}

function calculateSum(argument1, argument2) {
    return argument1 + argument2;
}

let a = 5;
let b = 10;
let sumOfFactorials = calculateSumOfFactorials(a, b);
console.log("The sum of factorials of the entered integers is", sumOfFactorials);</code></pre>
    <p>Veja se você consegue entender o que esse código está fazendo. Agora, antes de executá-lo de uma vez, experimente colocar um <b>breakpoint</b> na linha 20.</p>
    <p>Dentre as opções de depuração no vscode, você pode continuar a execução até o próximo breakpoint (<kbd>F5</kbd>), avançar (<kbd>F10</kbd>), entrar (<kbd>F11</kbd>), sair (<kbd>Shift + F11</kbd>).</p>
    <p>Na aba de depuração, você pode ver os valores das variáveis atuais, definir observadores (watch) de variáveis ou expressões, consultar a pilha de chamadas de funções e os breakpoints.</p>
    <p>Na aba "Debug Console", você pode escrever linhas de códigos que são executadas no contexto do programa atual, com acesso às suas variáveis e funções.</p>
    <p>No momento, essas informações podem parecer abstratas se você ainda está no início de sua jornada como programador. No entanto, depurar é uma ferramenta essencial para programadores e, à medida que você aprender mais, tudo ficará mais claro e fará mais sentido. Por isso, convido você a revisitar essa seção após adquirir mais maturidade em programação. Com o tempo e o conhecimento adquirido, essas práticas e termos farão mais sentido e serão uma parte natural do teu fluxo de trabalho como desenvolvedor.</p>

    <h2>Adicionando bibliotecas de terceiros.</h2>
    <p>Por padrão, ao instalar o node, o gerenciador de pacotes npm vem instalado junto. Porém, eu prefiro usar o gerenciador de pacotes pnpm, que é mais rápido e menor. Para instalar o pnpm, execute <code>npm install -g pnpm</code>. Uma vez instalado o pnpm, vamos configurar nosso projeto para ser gerenciado pelo pnpm. Dentro da pasta raiz do projeto, execute <code>pnpm init</code>. (Observação: Se estiver no Windows e não tiver permissão de executar scripts pelo terminal powershell, abra um powershell como administrador e execute <code>Set-ExecutionPolicy -ExecutionPolicy RemoteSigned</code>). É criado um arquivo <code>package.json</code>, que contém informações do teu projeto, como os pacotes que ele depende para ser executado.</p>
    <p>Geralmente programas grandes são compostos por vários arquivos de código-fonte, além dos pacotes de terceiro. O modo como o JavaScript estrutura e utiliza os arquivos é chamado de <i>module system</i>. Basicamente há dois sistemas de módulo para o JavaScript: o mais antigo, que vem habilitado por padrão, <i>CommonJS</i>; e o mais recente, que vamos substituir pelo antigo, <i>ECMAScript Modules</i> (ESM). Para tanto, adicione a seguinte linha no arquivo <code>package.json</code>:</p>
    <pre><code>  "type": "module",</code></pre>
    <p>O node não vem com uma maneira simples de ler entradas digitadas pelo terminal, pelo fato do foco do JavaScript ser desenvolvimento web. Mas para fins de aprendizado de algoritmos, é mais fácil interagirmos com nossos programas diretamente pelo terminal. Portanto, vamos instalar o utilitário de leitura de entradas por terminal <a href="https://github.com/Lellansin/node-scanf">node-scanf</a>. Execute <code>pnpm add scanf</code> na pasta raiz do projeto. Ao instalar um pacote com o pnpm, o pacote é colocado na pasta <code>node_modules</code> e também registrado no arquivo <code>package.json</code>.</p>
    <p>Por fim, para testar se está tudo em ordem, crie e execute o arquivo <code>cap02/input-output.js</code> com o seguinte código:</p>
    <pre><code>import scanf from 'scanf';

console.log('Please input your name');
let name = scanf('%s');

console.log('Please input your age');
let age = scanf('%d');

console.log('your name [%s] type: [%s]', name, typeof name);
console.log('your age [%s] type: [%s]', age, typeof age);</code></pre>

<p>Mais uma vez, não precisa se preocupar em entender tudo o que está se passando. Esse capítulo é mais para deixar tudo preparado para começarmos a aprender JavaScript no próximo capítulo. Se este último programa estiver funcionando conforme o esperado, ele vai te solicitar um nome e uma idade, e, depois que você informá-los, o programa responde com algumas mensagens.</p>

</div>